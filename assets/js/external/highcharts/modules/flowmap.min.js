!function(o){"object"==typeof module&&module.exports?module.exports=o.default=o:"function"==typeof define&&define.amd?define("highcharts/modules/flowmap",["highcharts"],function(t){return o(t),o.Highcharts=t,o}):o("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(s){"use strict";var t=s?s._modules:{};function o(t,o,i,e){t.hasOwnProperty(o)||(t[o]=e.apply(null,i),"function"==typeof CustomEvent&&s.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:o,module:t[o]}})))}o(t,"Series/FlowMap/FlowMapPoint.js",[t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,o){let{mapline:{prototype:{pointClass:i}}}=t["seriesTypes"],{pick:e,isString:s,isNumber:r}=o;return class extends i{isValid(){let o=!(!this.options.to||!this.options.from);return[this.options.to,this.options.from].forEach(function(t){o=!!(o&&t&&(s(t)||r(e(t[0],t.lat))&&r(e(t[1],t.lon))))}),o}}}),o(t,"Series/FlowMap/FlowMapSeries.js",[t["Series/FlowMap/FlowMapPoint.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Utilities.js"]],function(t,o,i){let{series:{prototype:{pointClass:f}},seriesTypes:{column:e,map:s,mapline:r}}=o,{addEvent:m,arrayMax:n,arrayMin:a,defined:C,extend:p,isArray:c,merge:W,pick:k,relativeLength:E}=i;class j extends r{static getLength(t,o){return Math.sqrt(t*t+o*o)}static normalize(t,o){var i=this.getLength(t,o);return[t/i,o/i]}static markerEndPath(t,o,i,e){let s=E(e.width||0,this.getLength(o[0]-t[0],o[1]-t[1])),r=e.markerType||"arrow",[n,a]=this.normalize(o[0]-t[0],o[1]-t[1]),p=[];var h,l,d,f;return"arrow"===r&&([e,h]=t,e-=n*s,h-=a*s,p.push(["L",e,h]),p.push(["L",i[0],i[1]]),[e,h]=o,e+=n*s,h+=a*s,p.push(["L",e,h])),"mushroom"===r&&([e,h]=t,[t,o]=o,[i,l]=i,d=(t-e)/2+e,f=(o-h)/2+h,e-=n*s,h-=a*s,p.push(["L",e,h]),t+=n*s,o+=a*s,p.push(["Q",2*(i-d)+d,2*(l-f)+f,t,o])),p}animate(t){let o=this.points;t||o.forEach(t=>{if(t.shapeArgs&&c(t.shapeArgs.d)&&t.shapeArgs.d.length){var e=t.shapeArgs.d,s=e[0][1],r=e[0][2];if(s&&r){let i=[];for(let o=0;o<e.length;o++){i.push([...e[o]]);for(let t=1;t<e[o].length;t++)i[o][t]=t%2?s:r}t.graphic&&(t.graphic.attr({d:i}),t.graphic.animate({d:e}))}}})}getLinkWidth(t){var o=this.options.width,i=t.options.weight||this.options.weight;if(t.options.weight=i,o&&!i)return o;t=this.smallestWeight,o=this.greatestWeight;if(!C(i)||!t||!o)return 0;var e=this.options.minWidth;return(i-t)*(this.options.maxWidth-e)/(o-t||1)+e}autoCurve(t,o,i,e,s,r){let n=i-t,a=e-o,p=(i-t)/2+t,h=(e-o)/2+o,l=p-s,d=h-r,f=n*l+a*d,m=Math.atan2(n*d-a*l,f),c=180*m/Math.PI;return c<0&&(c=360+c),-.7*Math.sin(c*Math.PI/180)}pointAttribs(t,o){let i=s.prototype.pointAttribs.call(this,t,o);return i.fill=k(t.options.fillColor,t.options.color,"none"===this.options.fillColor?null:this.options.fillColor,this.color),i["fill-opacity"]=k(t.options.fillOpacity,this.options.fillOpacity),i["stroke-width"]=k(t.options.lineWidth,this.options.lineWidth,1),t.options.opacity&&(i.opacity=t.options.opacity),i}translate(){!this.chart.hasRendered||!this.isDirtyData&&this.hasRendered||(this.processData(),this.generatePoints());let h=[],l=0,d=0;this.points.forEach(t=>{let o,i,e=this.chart,s=e.mapView,r=t.options,n=()=>{t.series.isDirty=!0},a=t=>{t=e.get(t);if(t instanceof f&&t.plotX&&t.plotY)return m(t,"update",n),{x:t.plotX,y:t.plotY}},p=t=>c(t)?{lon:t[0],lat:t[1]}:t;"string"==typeof r.from?o=a(r.from):"object"==typeof r.from&&s&&(o=s.lonLatToPixels(p(r.from))),"string"==typeof r.to?i=a(r.to):"object"==typeof r.to&&s&&(i=s.lonLatToPixels(p(r.to))),t.fromPos=o,t.toPos=i,o&&i&&(l+=(o.x+i.x)/2,d+=(o.y+i.y)/2),k(t.options.weight,this.options.weight)&&h.push(k(t.options.weight,this.options.weight))}),this.smallestWeight=a(h),this.greatestWeight=n(h),this.centerOfPoints={x:l/this.points.length,y:d/this.points.length},this.points.forEach(t=>{this.getLinkWidth(t)?(t.fromPos&&(t.plotX=t.fromPos.x,t.plotY=t.fromPos.y),t.shapeType="path",t.shapeArgs=this.getPointShapeArgs(t),t.color=k(t.options.color,t.series.color)):t.shapeArgs={d:[]}})}getPointShapeArgs(t){var{fromPos:o,toPos:i}=t;if(!o||!i)return{};let e=this.getLinkWidth(t)/2,s=t.options,r=W(this.options.markerEnd,s.markerEnd),n=k(s.growTowards,this.options.growTowards),a=o.x||0,p=o.y||0,h=i.x||0,l=i.y||0,d=k(s.curveFactor,this.options.curveFactor),f=r&&r.enabled&&r.height||0;C(d)||(d=this.autoCurve(a,p,h,l,this.centerOfPoints.x,this.centerOfPoints.y)),f&&(f=E(f,4*e),o=h-a,m=l-p,c=a+(o*=.5),g=p+(m*=.5),u=o,c=c+(o=m)*d,o=g+(m=-u)*d,[g,u]=j.normalize(c-h,o-l),g*=f,u*=f,h+=g,l+=u);var m=h-a,c=l-p,o=a+(m*=.5),g=p+(c*=.5),u=m,m=c,c=-u;let[y,w]=j.normalize(m,c),P=1+.25*Math.sqrt(d*d),v=(y*=e*P,w*=e*P,o+m*d),x=g+c*d,[M,L]=j.normalize(v-a,x-p);u=M,M=L,L=-u,M*=e,L*=e;var[o,m]=j.normalize(v-h,x-l),u=o,o=-m,m=u;o*=e,m*=e,n&&(M/=e,L/=e,y/=4,w/=4);let b={d:[["M",a-M,p-L],["Q",v-y,x-w,h-o,l-m],["L",h+o,l+m],["Q",v+y,x+w,a+M,p+L],["Z"]]};r&&r.enabled&&b.d&&(g=j.markerEndPath([h-o,l-m],[h+o,l+m],[i.x,i.y],r),b.d.splice(2,0,...g));c=t.options.from,u=t.options.to,o=c.lat,m=c.lon,i=u.lat,g=u.lon;return o&&m&&(t.options.from=+o+", "+ +m),i&&g&&(t.options.to=+i+", "+ +g),b}}return j.defaultOptions=W(r.defaultOptions,{animation:!0,dataLabels:{enabled:!1},fillOpacity:.5,markerEnd:{enabled:!0,height:"40%",width:"40%",markerType:"arrow"},width:1,maxWidth:25,minWidth:5,lineWidth:void 0,tooltip:{headerFormat:'<span style="font-size: 0.8em">{series.name}</span><br/>',pointFormat:"{point.options.from} â†’ {point.options.to}: <b>{point.options.weight}</b>"}}),p(j.prototype,{pointClass:t,pointArrayMap:["from","to","weight"],drawPoints:e.prototype.drawPoints,useMapGeometry:!0}),o.registerSeriesType("flowmap",j),j}),o(t,"masters/modules/flowmap.src.js",[t["Core/Globals.js"]],function(t){return t})});