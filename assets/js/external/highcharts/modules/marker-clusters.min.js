!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){"use strict";t=t?t._modules:{};function e(t,e,i,s){t.hasOwnProperty(e)||(t[e]=s.apply(null,i),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:e,module:t[e]}})))}e(t,"Extensions/MarkerClusters/MarkerClusterDefaults.js",[],function(){return{cluster:{enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}}),e(t,"Extensions/MarkerClusters/MarkerClusterScatter.js",[t["Core/Animation/AnimationUtilities.js"],t["Extensions/MarkerClusters/MarkerClusterDefaults.js"],t["Core/Utilities.js"]],function(t,i,e){let Y,C=t["animObject"],w=i["cluster"],{addEvent:D,defined:j,error:S,isArray:b,isFunction:L,isObject:A,isNumber:z,merge:v,objectEach:s,pushUnique:a,relativeLength:P,syncTimeout:k}=e,r=[],o={grid:function(t,e,i,s){let a,r,o,n,l,p={},u=this.getGridOffset(),d=this.getScaledGridSize(s);for(l=0;l<t.length;l++){var h=G(this,{x:t[l],y:e[l]});a=h.x-u.plotLeft,r=h.y-u.plotTop,o=Math.floor(a/d),p[n=Math.floor(r/d)+"-"+o]||(p[n]=[]),p[n].push({dataIndex:i[l],x:t[l],y:e[l]})}return p},kmeans:function(e,i,s,t){let a=[],r=[],o={},n=t.processedDistance||w.layoutAlgorithm.distance,l=t.iterations,p=0,u=!0,d,h,c,m=[];t.processedGridSize=t.processedDistance;var f,g=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,e,i,s,t):{};for(f in g)1<g[f].length&&(c=O(g[f]),a.push({posX:c.x,posY:c.y,oldX:0,oldY:0,startPointsLen:g[f].length,points:[]}));for(;u;){for(var x of a)x.points.length=0;for(let t=r.length=0;t<e.length;t++)d=e[t],h=i[t],((m=this.getClusterDistancesFromPoint(a,d,h)).length&&m[0].distance<n?a[m[0].clusterIndex].points:r).push({x:d,y:h,dataIndex:s[t]});for(let t=0;t<a.length;t++)1===a[t].points.length&&(m=this.getClusterDistancesFromPoint(a,a[t].points[0].x,a[t].points[0].y))[1].distance<n&&(a[m[1].clusterIndex].points.push(a[t].points[0]),a[m[0].clusterIndex].points.length=0);u=!1;for(let t=0;t<a.length;t++)c=O(a[t].points),a[t].oldX=a[t].posX,a[t].oldY=a[t].posY,a[t].posX=c.x,a[t].posY=c.y,(a[t].posX>a[t].oldX+1||a[t].posX<a[t].oldX-1||a[t].posY>a[t].oldY+1||a[t].posY<a[t].oldY-1)&&(u=!0);l&&(u=p<l-1),p++}for(let t=0,e=a.length;t<e;++t)o["cluster"+t]=a[t].points;for(let t=0,e=r.length;t<e;++t)o["noise"+t]=[r[t]];return o},optimizedKmeans:function(t,e,i,s){let a=s.processedDistance||w.layoutAlgorithm.gridSize,r=this.getRealExtremes(),o=(this.options.cluster||{}).marker,n,l={},p,u;if(!this.markerClusterInfo||this.initMaxX&&this.initMaxX<r.maxX||this.initMinX&&this.initMinX>r.minX||this.initMaxY&&this.initMaxY<r.maxY||this.initMinY&&this.initMinY>r.minY)this.initMaxX=r.maxX,this.initMinX=r.minX,this.initMaxY=r.maxY,this.initMinY=r.minY,l=this.markerClusterAlgorithms?this.markerClusterAlgorithms.kmeans.call(this,t,e,i,s):{},this.baseClusters=null;else{for(var d of(this.baseClusters||(this.baseClusters={clusters:this.markerClusterInfo.clusters,noise:this.markerClusterInfo.noise}),this.baseClusters.clusters)){for(var h of(d.pointsOutside=[],d.pointsInside=[],d.data)){var c=G(this,h),m=G(this,d);n=Math.sqrt(Math.pow(c.x-m.x,2)+Math.pow(c.y-m.y,2)),p=0<=a-(u=(d.clusterZone&&d.clusterZone.marker&&d.clusterZone.marker.radius?d.clusterZone.marker:o&&o.radius?o:w.marker).radius)?a-u:u,u+p<n&&j(d.pointsOutside)?d.pointsOutside.push(h):j(d.pointsInside)&&d.pointsInside.push(h)}d.pointsInside.length&&(l[d.id]=d.pointsInside);let t=0;for(var f of d.pointsOutside)l[d.id+"_noise"+t++]=[f]}for(var g of this.baseClusters.noise)l[g.id]=g.data}return l}},l=[],n=0;function p(t,e,i){t.attr({opacity:e}).animate({opacity:1},i)}function M(t,e,i,s){for(var a of(I(t,s,i,!0,!0),e))a.point&&a.point.destroy&&a.point.destroy()}function I(t,e,i,s,a){t.point&&(s&&t.point.graphic&&(t.point.graphic.show(),p(t.point.graphic,e,i)),a&&t.point.dataLabel&&(t.point.dataLabel.show(),p(t.point.dataLabel,e,i)))}function O(e){let i=e.length,s=0,a=0;for(let t=0;t<i;t++)s+=e[t].x,a+=e[t].y;return{x:s/i,y:a/i}}function u(t,e){let i=[];return i.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){i[t.dataIndex]=t})}),t.noise.forEach(function(t){i[t.data[0].dataIndex]=t.data[0]}),i}function X(){return Math.random().toString(36).substring(2,7)+"-"+n++}function E(t,e,i){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),i&&t.point.dataLabel&&t.point.dataLabel.hide())}function T(t){let e=t.point||t.target;e.firePointEvent("drillToCluster",t,function(t){let e=t.point||t.target,i=e.series,s=e.series.xAxis,a=e.series.yAxis,r=e.series.chart,o=r.mapView,n=i.options.cluster,l=(n||{}).drillToCluster;var p,u,d,h,c,m,f;l&&e.clusteredData&&(m=e.clusteredData.map(t=>t.x).sort((t,e)=>t-e),u=e.clusteredData.map(t=>t.y).sort((t,e)=>t-e),c=m[0],m=m[m.length-1],p=u[0],u=u[u.length-1],f=Math.abs(.1*(m-c)),d=Math.abs(.1*(u-p)),h=Math.min(c,m)-f,c=Math.max(c,m)+f,m=Math.min(p,u)-d,f=Math.max(p,u)+d,o?o.fitToBounds({x1:h,x2:c,y1:m,y2:f}):s&&a&&(r.pointer.zoomX=!0,r.pointer.zoomY=!0,r.zoom({originalEvent:t,xAxis:[{axis:s,min:h,max:c}],yAxis:[{axis:a,min:m,max:f}]})))})}function V(t,e){let{chart:i,xAxis:s,yAxis:a}=t;return i.mapView?i.mapView.pixelsToProjectedUnits(e):{x:s?s.toValue(e.x):0,y:a?a.toValue(e.y):0}}function d(t){let e=this.chart,i=e.mapView,s=this.options.cluster,a=C((s||{}).animation),r=a.duration||500,o=(this.markerClusterInfo||{}).pointsState,n=(o||{}).newState,l=(o||{}).oldState,p=[],u,d,h,c,m,f,g=!1,x=!1;var y;l&&n&&(y=G(this,d=n[t.stateId]),m=y.x-(i?0:e.plotLeft),f=y.y-(i?0:e.plotTop),1===d.parentsId.length?(u=l[(n||{})[t.stateId].parentsId[0]],d.point&&d.point.graphic&&u&&u.point&&u.point.plotX&&u.point.plotY&&u.point.plotX!==d.point.plotX&&u.point.plotY!==d.point.plotY&&(h=d.point.graphic.getBBox(),c=d.point.graphic&&d.point.graphic.isImg?0:h.width/2,d.point.graphic.attr({x:u.point.plotX-c,y:u.point.plotY-c}),d.point.graphic.animate({x:m-(d.point.graphic.radius||0),y:f-(d.point.graphic.radius||0)},a,function(){x=!0,u.point&&u.point.destroy&&u.point.destroy()}),d.point.dataLabel&&d.point.dataLabel.alignAttr&&u.point.dataLabel&&u.point.dataLabel.alignAttr&&(d.point.dataLabel.attr({x:u.point.dataLabel.alignAttr.x,y:u.point.dataLabel.alignAttr.y}),d.point.dataLabel.animate({x:d.point.dataLabel.alignAttr.x,y:d.point.dataLabel.alignAttr.y},a)))):0===d.parentsId.length?(E(d,!0,!0),k(function(){I(d,.1,a,!0,!0)},r/2)):(E(d,!0,!0),d.parentsId.forEach(function(t){l&&l[t]&&(u=l[t],p.push(u),u.point&&u.point.graphic&&(g=!0,u.point.graphic.show(),u.point.graphic.animate({x:m-(u.point.graphic.radius||0),y:f-(u.point.graphic.radius||0),opacity:.4},a,function(){x=!0,M(d,p,a,.7)}),u.point.dataLabel&&-9999!==u.point.dataLabel.y&&d.point&&d.point.dataLabel&&d.point.dataLabel.alignAttr&&(u.point.dataLabel.show(),u.point.dataLabel.animate({x:d.point.dataLabel.alignAttr.x,y:d.point.dataLabel.alignAttr.y,opacity:.4},a))))}),k(function(){x||M(d,p,a,.85)},r),g||k(function(){M(d,p,a,.1)},r/2)))}function h(){let t=this.markerClusterSeriesData;(t||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null}function c(){let t,e,i,s,a,r,o,n,l,p,u,d,h,c,m,f,g=this,x=g.chart,y=x.mapView,C=g.xData,k=g.yData,M=g.options.cluster,I=g.getRealExtremes(),S=[],b=[],A=[];if(y&&g.is("mappoint")&&C&&k&&(g.options.data||[]).forEach((t,e)=>{t=g.projectPoint(t);t&&(C[e]=t.x,k[e]=t.y)}),M&&M.enabled&&C&&C.length&&k&&k.length&&!x.polar){u=M.layoutAlgorithm.type,(c=M.layoutAlgorithm).processedGridSize=P(c.gridSize||w.layoutAlgorithm.gridSize,x.plotWidth),c.processedDistance=P(c.distance||w.layoutAlgorithm.distance,x.plotWidth),s=c.kmeansThreshold||w.layoutAlgorithm.kmeansThreshold;var v=c.processedGridSize/2,X=V(g,{x:0,y:0}),v=V(g,{x:v,y:v});for(f=0,a=Math.abs(X.x-v.x),r=Math.abs(X.y-v.y);f<C.length;f++)g.dataMaxX||(j(n)&&j(o)&&j(p)&&j(l)?z(k[f])&&z(p)&&z(l)&&(n=Math.max(C[f],n),o=Math.min(C[f],o),p=Math.max(k[f]||p,p),l=Math.min(k[f]||l,l)):(n=o=C[f],p=l=k[f])),C[f]>=I.minX-a&&C[f]<=I.maxX+a&&(k[f]||I.minY)>=I.minY-r&&(k[f]||I.maxY)<=I.maxY+r&&(S.push(C[f]),b.push(k[f]),A.push(f));j(n)&&j(o)&&z(p)&&z(l)&&(g.dataMaxX=n,g.dataMinX=o,g.dataMaxY=p,g.dataMinY=l),d=(h=(L(u)?u:g.markerClusterAlgorithms?u&&g.markerClusterAlgorithms[u]?g.markerClusterAlgorithms[u]:S.length<s?g.markerClusterAlgorithms.kmeans:g.markerClusterAlgorithms.grid:function(){return!1}).call(this,S,b,A,c))?g.getClusteredData(h,M):h,t=M.animation&&g.markerClusterInfo&&g.markerClusterInfo.pointsState&&g.markerClusterInfo.pointsState.oldState?(function(e){if(e){let t;for(var i of Object.keys(e))(t=e[i]).point&&t.point.destroy&&t.point.destroy()}}(g.markerClusterInfo.pointsState.oldState),g.markerClusterInfo.pointsState.newState):{},e=C.length,i=g.markerClusterInfo,d&&(g.processedXData=d.groupedXData,g.processedYData=d.groupedYData,g.hasGroupedData=!0,g.markerClusterInfo=d,g.groupMap=d.groupMap),Y.apply(this),d&&g.markerClusterInfo&&((g.markerClusterInfo.clusters||[]).forEach(function(t){(m=g.points[t.index]).isCluster=!0,m.clusteredData=t.data,m.clusterPointsAmount=t.data.length,t.point=m,D(m,"click",T)}),(g.markerClusterInfo.noise||[]).forEach(function(t){t.point=g.points[t.index]}),M.animation&&g.markerClusterInfo&&(g.markerClusterInfo.pointsState={oldState:t,newState:g.getPointsState(d,i,e)}),M.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else Y.apply(this)}function m(e,i,s){let a=[];for(let t=0;t<e.length;t++){var r=G(this,{x:i,y:s}),o=G(this,{x:e[t].posX,y:e[t].posY}),r=Math.sqrt(Math.pow(r.x-o.x,2)+Math.pow(r.y-o.y,2));a.push({clusterIndex:t,distance:r})}return a.sort((t,e)=>t.distance-e.distance)}function f(t,e){let i=[],s=[],a=[],r=[],o=[],n=Math.max(2,e.minimumClusterSize||2),l=0,p,u,d,h,c,m,f,g,x,y,C,k,M,I;if(L(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return S("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(I in t)if(t[I].length>=n){if(d=t[I],p=X(),c=d.length,e.zones)for(M=0;M<e.zones.length;M++)c>=e.zones[M].from&&c<=e.zones[M].to&&((C=e.zones[M]).zoneIndex=M,y=e.zones[M].marker,k=e.zones[M].className);for(x=O(d),f="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:x.x,y:x.y}:(m=this.options.marker||{},this.preventClusterCollisions({x:x.x,y:x.y,key:I,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:m.radius||3+(m.lineWidth||0),clusterRadius:y&&y.radius?y.radius:(e.marker||{}).radius||w.marker.radius})),M=0;M<c;M++)d[M].parentStateId=p;if(a.push({x:f.x,y:f.y,id:I,stateId:p,index:l,data:d,clusterZone:C,clusterZoneClassName:k}),i.push(f.x),s.push(f.y),o.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:v(e.marker,{states:e.states},y||{})}}),this.options.data&&this.options.data.length)for(M=0;M<c;M++)A(this.options.data[d[M].dataIndex])&&(d[M].options=this.options.data[d[M].dataIndex]);l++,y=null}else for(M=0;M<t[I].length;M++)u=t[I][M],p=X(),h=((this.options||{}).data||[])[u.dataIndex],i.push(u.x),s.push(u.y),u.parentStateId=p,r.push({x:u.x,y:u.y,id:I,stateId:p,index:l,data:t[I]}),g=h&&"object"==typeof h&&!b(h)?v(h,{x:u.x,y:u.y}):{userOptions:h,x:u.x,y:u.y},o.push({options:g}),l++;return{clusters:a,noise:r,groupedXData:i,groupedYData:s,groupMap:o}}function g(){let t=this.chart,e=this.xAxis,i=this.yAxis;return{plotLeft:e&&this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:i&&this.dataMinY&&this.dataMaxY?i.reversed?i.toPixels(this.dataMinY):i.toPixels(this.dataMaxY):t.plotTop}}function x(t,e,i){var s,a;let r=e?u(e,i):[],o=u(t,i),n={};l=[],t.clusters.forEach(function(t){n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<o.length;t++)s=o[t],a=r[t],s&&a&&s.parentStateId&&a.parentStateId&&n[s.parentStateId]&&-1===n[s.parentStateId].parentsId.indexOf(a.parentStateId)&&(n[s.parentStateId].parentsId.push(a.parentStateId),-1===l.indexOf(a.parentStateId)&&l.push(a.parentStateId));return n}function y(){var t=this.chart,e=t.mapView?0:t.plotLeft,i=V(this,{x:e,y:t.mapView?0:t.plotTop}),e=V(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=i.x,s=e.x,i=i.y,e=e.y;return{minX:Math.min(t,s),maxX:Math.max(t,s),minY:Math.min(i,e),maxY:Math.max(i,e)}}function R(t){let e=this.xAxis,i=this.chart.mapView,s=t.processedGridSize||w.layoutAlgorithm.gridSize,a=!0,r=1,o=1;this.gridValueSize||(i?this.gridValueSize=s/i.getScale():this.gridValueSize=Math.abs(e.toValue(s)-e.toValue(0)));for(var n=+(s/(i?this.gridValueSize*i.getScale():e.toPixels(this.gridValueSize)-e.toPixels(0))).toFixed(14);a&&1!=n;){var l=Math.pow(2,r);.75<n&&n<1.25?a=!1:1/l<=n&&n<1/l*2?(a=!1,o=l):n<=l&&l/2<n&&(a=!1,o=1/l),r++}return s/o/n}function U(){let t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},i=l.map(t=>(e[t].point||{}).id||"");(t||[]).forEach(function(t){t&&-1!==i.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})}function F(t){let e=!1,i;return!!A(t)&&(s(t,function(t){if(e=!0,b(t)&&t.length){for(i=0;i<t.length;i++)if(!A(t[i])||!t[i].x||!t[i].y)return void(e=!1)}else e=!1}),e)}function Z(t){let[e,i]=t.key.split("-").map(parseFloat),s=t.gridSize,a=t.groupedData,r=t.defaultRadius,o=t.clusterRadius,n=i*s,l=e*s,p=G(this,t),u=[],d=(this.options.cluster||{}).marker,h=(this.options.cluster||{}).zones,c=this.getGridOffset(),m=p.x,f=p.y,g,x=0,y,C,k,M,I,S,b,A,v,X,Y,D,L;for(m-=c.plotLeft,f-=c.plotTop,b=1;b<5;b++)for(A=0,k=b%2?-1:1,M=b<3?-1:1,I=Math.floor((m+k*o)/s),L=[(S=Math.floor((f+M*o)/s))+"-"+I,S+"-"+i,e+"-"+I];A<L.length;A++)-1===u.indexOf(L[A])&&L[A]!==t.key&&u.push(L[A]);for(var z of u)if(a[z]){a[z].posX||(Y=O(a[z]),a[z].posX=Y.x,a[z].posY=Y.y);var P=G(this,{x:a[z].posX||0,y:a[z].posY||0});if(y=P.x-c.plotLeft,C=P.y-c.plotTop,[X,v]=z.split("-").map(parseFloat),h)for(b=0,g=a[z].length;b<h.length;b++)g>=h[b].from&&g<=h[b].to&&(x=j((h[b].marker||{}).radius)?h[b].marker.radius||0:(d&&d.radius?d:w.marker).radius);1<a[z].length&&0===x&&d&&d.radius?x=d.radius:1===a[z].length&&(x=r),D=o+x,x=0,v!==i&&Math.abs(m-y)<D&&(m=v-i<0?n+o:n+s-o),X!==e&&Math.abs(f-C)<D&&(f=X-e<0?l+o:l+s-o)}var E=V(this,{x:m+c.plotLeft,y:f+c.plotTop});return a[t.key].posX=E.x,a[t.key].posY=E.y,E}function G(t,e){let{chart:i,xAxis:s,yAxis:a}=t;return i.mapView?i.mapView.projectedUnitsToPixels(e):{x:s?s.toPixels(e.x):0,y:a?a.toPixels(e.y):0}}return{compose:function(t,e){if(a(r,e)){let t=e.prototype;Y=t.generatePoints,t.markerClusterAlgorithms=o,t.animateClusterPoint=d,t.destroyClusteredData=h,t.generatePoints=c,t.getClusterDistancesFromPoint=m,t.getClusteredData=f,t.getGridOffset=g,t.getPointsState=x,t.getRealExtremes=y,t.getScaledGridSize=R,t.hideClusteredData=U,t.isValidGroupedDataObject=F,t.preventClusterCollisions=Z,D(e,"destroy",t.destroyClusteredData)}a(r,t)&&((t.plotOptions||{}).series=v((t.plotOptions||{}).series,i))}}}),e(t,"Extensions/MarkerClusters/MarkerClusters.js",[t["Core/Animation/AnimationUtilities.js"],t["Core/Defaults.js"],t["Extensions/MarkerClusters/MarkerClusterDefaults.js"],t["Extensions/MarkerClusters/MarkerClusterScatter.js"],t["Core/Utilities.js"]],function(t,e,i,r,s){let a=t["animObject"],o=e["defaultOptions"],{addEvent:n,defined:l,error:p,isFunction:u,merge:d,pushUnique:h,syncTimeout:c}=s,m=[];function f(){let t=this.chart,e=0;for(var i of t.series)i.markerClusterInfo&&(e=a((i.options.cluster||{}).animation).duration||0);c(()=>{t.tooltip&&t.tooltip.destroy()},e)}function g(){for(var t of this.series||[])if(t.markerClusterInfo){var e=t.options.cluster,i=((t.markerClusterInfo||{}).pointsState||{}).oldState;if((e||{}).animation&&t.markerClusterInfo&&0===t.chart.pointer.pinchDown.length&&"pan"!==((t.xAxis||{}).eventArgs||{}).trigger&&i&&Object.keys(i).length){for(var s of t.markerClusterInfo.clusters)t.animateClusterPoint(s);for(var a of t.markerClusterInfo.noise)t.animateClusterPoint(a)}}}function x(t){let e=t.point||t.target,i=e.series,s=i.options.cluster,a=((s||{}).events||{}).drillToCluster;u(a)&&a.call(this,t)}function y(){if(this.dataGroup)return p("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}function C(){var t=(this.options.cluster||{}).drillToCluster;if(this.markerClusterInfo&&this.markerClusterInfo.clusters)for(var e of this.markerClusterInfo.clusters)e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),l(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))}return(o.plotOptions||{}).series=d((o.plotOptions||{}).series,i),{compose:function(t,e,i,s){var a=s.prototype.pointClass,t=(h(m,t)&&n(t,"setExtremes",f),h(m,e)&&n(e,"render",g),h(m,a)&&(n(a,"drillToCluster",x),n(a,"update",y)),h(m,s)&&n(s,"afterRender",C),s.types)["scatter"];t&&r.compose(i,t)}}}),e(t,"Extensions/MarkerClusters/MarkerClusterSymbols.js",[t["Core/Utilities.js"]],function(t){let p,e=t["pushUnique"],i=[];function s(t,e,i,s){let a=i/2,r=s/2,o=p.arc(t+a,e+r,a-4,r-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),n=p.arc(t+a,e+r,a-3,r-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a-2,open:!1}),l=p.arc(t+a,e+r,a-1,r-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a,open:!1});return l.concat(n,o)}return{compose:function(t){e(i,t)&&((p=t.prototype.symbols).cluster=s)}}}),e(t,"masters/modules/marker-clusters.src.js",[t["Core/Globals.js"],t["Extensions/MarkerClusters/MarkerClusters.js"],t["Extensions/MarkerClusters/MarkerClusterSymbols.js"]],function(t,e,i){e.compose(t.Axis,t.Chart,t.defaultOptions,t.Series),i.compose(t.SVGRenderer)})});