"use strict";!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){function e(t,e,a,i){t.hasOwnProperty(e)||(t[e]=i.apply(null,a),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:e,module:t[e]}})))}e(t=t?t._modules:{},"Extensions/MarkerClusters.js",[t["Core/Animation/AnimationUtilities.js"],t["Core/Chart/Chart.js"],t["Core/Defaults.js"],t["Core/Series/Point.js"],t["Core/Series/Series.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Renderer/SVG/SVGRenderer.js"],t["Core/Utilities.js"],t["Core/Axis/Axis.js"]],function(t,e,a,i,o,r,s,n,l){function Y(t){let e=t.length,a=0,i=0,o;for(o=0;o<e;o++)a+=t[o].x,i+=t[o].y;return{x:a/e,y:i/e}}function p(t,e){const a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function f(t,e,a,i,o){t.point&&(i&&t.point.graphic&&(t.point.graphic.show(),t.point.graphic.attr({opacity:e}).animate({opacity:1},a)),o&&t.point.dataLabel&&(t.point.dataLabel.show(),t.point.dataLabel.attr({opacity:e}).animate({opacity:1},a)))}function g(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function x(t,e,a,i){f(t,i,a,!0,!0),e.forEach(function(t){t.point&&t.point.destroy&&t.point.destroy()})}const y=t["animObject"],{symbols:u}=(t=a["defaultOptions"],r=r["seriesTypes"],s)["prototype"],{addEvent:C,defined:L,error:I,isArray:k,isFunction:M,isObject:S,isNumber:b,merge:A,objectEach:X,relativeLength:D,syncTimeout:v}=n,E=(s=r.scatter,o.prototype.generatePoints);let d=[],P=0;const z={enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},w=((t.plotOptions||{}).series=A((t.plotOptions||{}).series,{cluster:z,tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}),(t,e)=>{const{chart:a,xAxis:i,yAxis:o}=t;return a.mapView?a.mapView.pixelsToProjectedUnits(e):{x:i?i.toValue(e.x):0,y:o?o.toValue(e.y):0}}),T=(t,e)=>{const{chart:a,xAxis:i,yAxis:o}=t;return a.mapView?a.mapView.projectedUnitsToPixels(e):{x:i?i.toPixels(e.x):0,y:o?o.toPixels(e.y):0}};u.cluster=function(t,e,a,i){a/=2,i/=2;var o=u.arc(t+a,e+i,a-4,i-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),r=u.arc(t+a,e+i,a-3,i-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a-2,open:!1});return u.arc(t+a,e+i,a-1,i-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a,open:!1}).concat(r,o)},s.prototype.animateClusterPoint=function(t){const e=this.chart,a=e.mapView,i=y((this.options.cluster||{}).animation),o=i.duration||500;var r=(this.markerClusterInfo||{}).pointsState;const s=(r||{}).newState,n=(r||{}).oldState,l=[];let p,u,d,h,c=!1,m=!1;n&&s&&(u=s[t.stateId],r=T(this,u),d=r.x-(a?0:e.plotLeft),h=r.y-(a?0:e.plotTop),1===u.parentsId.length?(t=(s||{})[t.stateId].parentsId[0],p=n[t],u.point&&u.point.graphic&&p&&p.point&&p.point.plotX&&p.point.plotY&&p.point.plotX!==u.point.plotX&&p.point.plotY!==u.point.plotY&&(t=u.point.graphic.getBBox(),r=u.point.graphic&&u.point.graphic.isImg?0:t.width/2,u.point.graphic.attr({x:p.point.plotX-r,y:p.point.plotY-r}),u.point.graphic.animate({x:d-(u.point.graphic.radius||0),y:h-(u.point.graphic.radius||0)},i,function(){m=!0,p.point&&p.point.destroy&&p.point.destroy()}),u.point.dataLabel&&u.point.dataLabel.alignAttr&&p.point.dataLabel&&p.point.dataLabel.alignAttr&&(u.point.dataLabel.attr({x:p.point.dataLabel.alignAttr.x,y:p.point.dataLabel.alignAttr.y}),u.point.dataLabel.animate({x:u.point.dataLabel.alignAttr.x,y:u.point.dataLabel.alignAttr.y},i)))):0===u.parentsId.length?(g(u,!0,!0),v(function(){f(u,.1,i,!0,!0)},o/2)):(g(u,!0,!0),u.parentsId.forEach(function(t){n&&n[t]&&(p=n[t],l.push(p),p.point&&p.point.graphic&&(c=!0,p.point.graphic.show(),p.point.graphic.animate({x:d-(p.point.graphic.radius||0),y:h-(p.point.graphic.radius||0),opacity:.4},i,function(){m=!0,x(u,l,i,.7)}),p.point.dataLabel&&-9999!==p.point.dataLabel.y&&u.point&&u.point.dataLabel&&u.point.dataLabel.alignAttr&&(p.point.dataLabel.show(),p.point.dataLabel.animate({x:u.point.dataLabel.alignAttr.x,y:u.point.dataLabel.alignAttr.y,opacity:.4},i))))}),v(function(){m||x(u,l,i,.85)},o),c||v(function(){x(u,l,i,.1)},o/2)))},s.prototype.getGridOffset=function(){var t=this.chart,e=this.xAxis;let a=this.yAxis;return{plotLeft:e=e&&this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:t=a&&this.dataMinY&&this.dataMaxY?a.reversed?a.toPixels(this.dataMinY):a.toPixels(this.dataMaxY):t.plotTop}},s.prototype.getScaledGridSize=function(t){var e=this.xAxis,a=this.chart.mapView;t=t.processedGridSize||z.layoutAlgorithm.gridSize;let i=!0,o=1,r=1;for(this.gridValueSize||(this.gridValueSize=a?t/a.getScale():Math.abs(e.toValue(t)-e.toValue(0))),e=+(t/(e=a?this.gridValueSize*a.getScale():e.toPixels(this.gridValueSize)-e.toPixels(0))).toFixed(14);i&&1!==e;)a=Math.pow(2,o),.75<e&&e<1.25?i=!1:1/a<=e&&e<1/a*2?(i=!1,r=a):e<=a&&a/2<e&&(i=!1,r=1/a),o++;return t/r/e},s.prototype.getRealExtremes=function(){var t=(i=this.chart).mapView?0:i.plotLeft,e=w(this,{x:t,y:i.mapView?0:i.plotTop}),a=w(this,{x:t+i.plotWidth,y:t+i.plotHeight}),i=e.x,t=a.x,e=e.y,a=a.y;return{minX:Math.min(i,t),maxX:Math.max(i,t),minY:Math.min(e,a),maxY:Math.max(e,a)}},s.prototype.onDrillToCluster=function(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){var e,a,i,o,r,s,n=t.point||t.target;const l=n.series.xAxis,p=n.series.yAxis,u=n.series.chart,d=u.mapView;(n.series.options.cluster||{}).drillToCluster&&n.clusteredData&&(i=n.clusteredData.map(t=>t.x).sort((t,e)=>t-e),n=n.clusteredData.map(t=>t.y).sort((t,e)=>t-e),e=i[0],a=i[i.length-1],i=n[0],o=n[n.length-1],r=Math.abs(.1*(a-e)),s=Math.abs(.1*(o-i)),n=Math.min(e,a)-r,e=Math.max(e,a)+r,a=Math.min(i,o)-s,i=Math.max(i,o)+s,d?d.fitToBounds({x1:n,x2:e,y1:a,y2:i}):l&&p&&(u.pointer.zoomX=!0,u.pointer.zoomY=!0,u.zoom({originalEvent:t,xAxis:[{axis:l,min:n,max:e}],yAxis:[{axis:p,min:a,max:i}]})))})},s.prototype.getClusterDistancesFromPoint=function(e,a,i){const o=[];for(let t=0;t<e.length;t++){var r=T(this,{x:a,y:i}),s=T(this,{x:e[t].posX,y:e[t].posY});o.push({clusterIndex:t,distance:Math.sqrt(Math.pow(r.x-s.x,2)+Math.pow(r.y-s.y,2))})}return o.sort((t,e)=>t.distance-e.distance)},s.prototype.getPointsState=function(t,e,a){e=e?p(e,a):[],a=p(t,a);let i={},o,r;for(d=[],t.clusters.forEach(function(t){i[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){i[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),r=0;r<a.length;r++)t=a[r],o=e[r],t&&o&&t.parentStateId&&o.parentStateId&&i[t.parentStateId]&&-1===i[t.parentStateId].parentsId.indexOf(o.parentStateId)&&(i[t.parentStateId].parentsId.push(o.parentStateId),-1===d.indexOf(o.parentStateId)&&d.push(o.parentStateId));return i},s.prototype.markerClusterAlgorithms={grid:function(t,e,a,i){const o={},r=this.getGridOffset();var s=this.getScaledGridSize(i);for(i=0;i<t.length;i++){var n=(l=T(this,{x:t[i],y:e[i]})).x-r.plotLeft,l=l.y-r.plotTop,n=Math.floor(n/s);n=Math.floor(l/s)+"-"+n,o[n]||(o[n]=[]),o[n].push({dataIndex:a[i],x:t[i],y:e[i]})}return o},kmeans:function(t,e,a,i){let o=[],r=[],s={},n=i.processedDistance||z.layoutAlgorithm.distance,l=i.iterations,p=0;var u,d,h=!0,c=0,m=[];for(d in i.processedGridSize=i.processedDistance,c=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,t,e,a,i):{})1<c[d].length&&(m=Y(c[d]),o.push({posX:m.x,posY:m.y,oldX:0,oldY:0,startPointsLen:c[d].length,points:[]}));for(;h;){for(o.map(t=>(t.points.length=0,t)),h=r.length=0;h<t.length;h++)c=t[h],u=e[h],((m=this.getClusterDistancesFromPoint(o,c,u)).length&&m[0].distance<n?o[m[0].clusterIndex].points:r).push({x:c,y:u,dataIndex:a[h]});for(d=0;d<o.length;d++)1===o[d].points.length&&((m=this.getClusterDistancesFromPoint(o,o[d].points[0].x,o[d].points[0].y))[1].distance<n&&(o[m[1].clusterIndex].points.push(o[d].points[0]),o[m[0].clusterIndex].points.length=0));for(h=!1,d=0;d<o.length;d++)m=Y(o[d].points),o[d].oldX=o[d].posX,o[d].oldY=o[d].posY,o[d].posX=m.x,o[d].posY=m.y,(o[d].posX>o[d].oldX+1||o[d].posX<o[d].oldX-1||o[d].posY>o[d].oldY+1||o[d].posY<o[d].oldY-1)&&(h=!0);l&&(h=p<l-1),p++}return o.forEach(function(t,e){s["cluster"+e]=t.points}),r.forEach(function(t,e){s["noise"+e]=[t]}),s},optimizedKmeans:function(t,e,a,i){let o=this,r=i.processedDistance||z.layoutAlgorithm.gridSize,s={},n=o.getRealExtremes(),l=(o.options.cluster||{}).marker,p,u,d;return!o.markerClusterInfo||o.initMaxX&&o.initMaxX<n.maxX||o.initMinX&&o.initMinX>n.minX||o.initMaxY&&o.initMaxY<n.maxY||o.initMinY&&o.initMinY>n.minY?(o.initMaxX=n.maxX,o.initMinX=n.minX,o.initMaxY=n.maxY,o.initMinY=n.minY,s=o.markerClusterAlgorithms?o.markerClusterAlgorithms.kmeans.call(o,t,e,a,i):{},o.baseClusters=null):(o.baseClusters||(o.baseClusters={clusters:o.markerClusterInfo.clusters,noise:o.markerClusterInfo.noise}),o.baseClusters.clusters.forEach(function(i){i.pointsOutside=[],i.pointsInside=[],i.data.forEach(function(t){var e=T(o,t),a=T(o,i);u=Math.sqrt(Math.pow(e.x-a.x,2)+Math.pow(e.y-a.y,2)),d=(i.clusterZone&&i.clusterZone.marker&&i.clusterZone.marker.radius?i.clusterZone.marker:l&&l.radius?l:z.marker).radius,p=0<=r-d?r-d:d,u>d+p&&L(i.pointsOutside)?i.pointsOutside.push(t):L(i.pointsInside)&&i.pointsInside.push(t)}),i.pointsInside.length&&(s[i.id]=i.pointsInside),i.pointsOutside.forEach(function(t,e){s[i.id+"_noise"+e]=[t]})}),o.baseClusters.noise.forEach(function(t){s[t.id]=t.data})),s}},s.prototype.preventClusterCollisions=function(t){let a=this,[i,o]=t.key.split("-").map(parseFloat),r=t.gridSize,s=t.groupedData,n=t.defaultRadius,l=t.clusterRadius,p=o*r,u=i*r;var e=T(a,t);let d=e.x,h=e.y,c=void(e=[]),m=0,f=(a.options.cluster||{}).marker,g=(a.options.cluster||{}).zones,x=a.getGridOffset(),y,C,I,k,M,S,b;for(d-=x.plotLeft,h-=x.plotTop,I=1;I<5;I++){var A=I%2?-1:1,X=I<3?-1:1,A=Math.floor((d+A*l)/r);for(A=[(X=Math.floor((h+X*l)/r))+"-"+A,X+"-"+o,i+"-"+A],X=0;X<A.length;X++)-1===e.indexOf(A[X])&&A[X]!==t.key&&e.push(A[X])}return e.forEach(function(t){if(s[t]){s[t].posX||(S=Y(s[t]),s[t].posX=S.x,s[t].posY=S.y);var e=T(a,{x:s[t].posX||0,y:s[t].posY||0});if(y=e.x-x.plotLeft,C=e.y-x.plotTop,[M,k]=t.split("-").map(parseFloat),g)for(c=s[t].length,I=0;I<g.length;I++)c>=g[I].from&&c<=g[I].to&&(m=L((g[I].marker||{}).radius)?g[I].marker.radius||0:(f&&f.radius?f:z.marker).radius);1<s[t].length&&0===m&&f&&f.radius?m=f.radius:1===s[t].length&&(m=n),b=l+m,m=0,k!==o&&Math.abs(d-y)<b&&(d=k-o<0?p+l:p+r-l),M!==i&&Math.abs(h-C)<b&&(h=M-i<0?u+l:u+r-l)}}),e=w(a,{x:d+x.plotLeft,y:h+x.plotTop}),s[t.key].posX=e.x,s[t.key].posY=e.y,e},s.prototype.isValidGroupedDataObject=function(t){let e=!1,a;return!!S(t)&&(X(t,function(t){if(e=!0,k(t)&&t.length){for(a=0;a<t.length;a++)if(!S(t[a])||!t[a].x||!t[a].y){e=!1;break}}else e=!1}),e)},s.prototype.getClusteredData=function(t,e){let a=[],i=[],o=[],r=[],s=[],n=0,l=Math.max(2,e.minimumClusterSize||2);let p,u,d,h;if(M(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return I("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(h in t)if(t[h].length>=l){var c=t[h],m=Math.random().toString(36).substring(2,7)+"-"+P++,f=c.length;if(e.zones)for(x=0;x<e.zones.length;x++)f>=e.zones[x].from&&f<=e.zones[x].to&&((u=e.zones[x]).zoneIndex=x,p=e.zones[x].marker,d=e.zones[x].className);for(var g=Y(c),g="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:g.x,y:g.y}:(x=this.options.marker||{},this.preventClusterCollisions({x:g.x,y:g.y,key:h,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:x.radius||3+(x.lineWidth||0),clusterRadius:p&&p.radius?p.radius:(e.marker||{}).radius||z.marker.radius})),x=0;x<f;x++)c[x].parentStateId=m;if(o.push({x:g.x,y:g.y,id:h,stateId:m,index:n,data:c,clusterZone:u,clusterZoneClassName:d}),a.push(g.x),i.push(g.y),s.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:A(e.marker,{states:e.states},p||{})}}),this.options.data&&this.options.data.length)for(x=0;x<f;x++)S(this.options.data[c[x].dataIndex])&&(c[x].options=this.options.data[c[x].dataIndex]);n++,p=null}else for(x=0;x<t[h].length;x++)c=t[h][x],m=Math.random().toString(36).substring(2,7)+"-"+P++,f=((this.options||{}).data||[])[c.dataIndex],a.push(c.x),i.push(c.y),c.parentStateId=m,r.push({x:c.x,y:c.y,id:h,stateId:m,index:n,data:t[h]}),m=f&&"object"==typeof f&&!k(f)?A(f,{x:c.x,y:c.y}):{userOptions:f,x:c.x,y:c.y},s.push({options:m}),n++;return{clusters:o,noise:r,groupedXData:a,groupedYData:i,groupMap:s}},s.prototype.destroyClusteredData=function(){(this.markerClusterSeriesData||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null},s.prototype.hideClusteredData=function(){const t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},a=d.map(t=>(e[t].point||{}).id||"");(t||[]).forEach(function(t){t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})},s.prototype.generatePoints=function(){const a=this;var t=(f=a.chart).mapView;const i=a.xData,o=a.yData,e=a.options.cluster;var r=a.getRealExtremes(),s=[],n=[],l=[];let p,u,d,h,c,m;if(t&&a.is("mappoint")&&i&&o&&(a.options.data||[]).forEach((t,e)=>{(t=a.projectPoint(t))&&(i[e]=t.x,o[e]=t.y)}),e&&e.enabled&&i&&i.length&&o&&o.length&&!f.polar){c=e.layoutAlgorithm.type,(t=e.layoutAlgorithm).processedGridSize=D(t.gridSize||z.layoutAlgorithm.gridSize,f.plotWidth),t.processedDistance=D(t.distance||z.layoutAlgorithm.distance,f.plotWidth);for(var f=t.kmeansThreshold||z.layoutAlgorithm.kmeansThreshold,g=t.processedGridSize/2,x=w(a,{x:0,y:0}),y=w(a,{x:g,y:g}),g=Math.abs(x.x-y.x),x=Math.abs(x.y-y.y),y=0;y<i.length;y++)a.dataMaxX||(L(u)&&L(p)&&L(h)&&L(d)?b(o[y])&&b(h)&&b(d)&&(u=Math.max(i[y],u),p=Math.min(i[y],p),h=Math.max(o[y]||h,h),d=Math.min(o[y]||d,d)):(u=p=i[y],h=d=o[y])),i[y]>=r.minX-g&&i[y]<=r.maxX+g&&(o[y]||r.minY)>=r.minY-x&&(o[y]||r.maxY)<=r.maxY+x&&(s.push(i[y]),n.push(o[y]),l.push(y));L(u)&&L(p)&&b(h)&&b(d)&&(a.dataMaxX=u,a.dataMinX=p,a.dataMaxY=h,a.dataMinY=d),r=(s=(r=M(c)?c:a.markerClusterAlgorithms?c&&a.markerClusterAlgorithms[c]?a.markerClusterAlgorithms[c]:s.length<f?a.markerClusterAlgorithms.kmeans:a.markerClusterAlgorithms.grid:function(){return!1}).call(this,s,n,l,t))?a.getClusteredData(s,e):s,s=e.animation&&a.markerClusterInfo&&a.markerClusterInfo.pointsState&&a.markerClusterInfo.pointsState.oldState?((f=a.markerClusterInfo.pointsState.oldState)&&X(f,function(t){t.point&&t.point.destroy&&t.point.destroy()}),a.markerClusterInfo.pointsState.newState):{},n=i.length,l=a.markerClusterInfo,r&&(a.processedXData=r.groupedXData,a.processedYData=r.groupedYData,a.hasGroupedData=!0,a.markerClusterInfo=r,a.groupMap=r.groupMap),E.apply(this),r&&a.markerClusterInfo&&((a.markerClusterInfo.clusters||[]).forEach(function(t){(m=a.points[t.index]).isCluster=!0,m.clusteredData=t.data,m.clusterPointsAmount=t.data.length,t.point=m,C(m,"click",a.onDrillToCluster)}),(a.markerClusterInfo.noise||[]).forEach(function(t){t.point=a.points[t.index]}),e.animation&&a.markerClusterInfo&&(a.markerClusterInfo.pointsState={oldState:s,newState:a.getPointsState(r,l,n)}),e.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else E.apply(this)},C(e,"render",function(){(this.series||[]).forEach(function(e){var t;e.markerClusterInfo&&(t=((e.markerClusterInfo||{}).pointsState||{}).oldState,(e.options.cluster||{}).animation&&e.markerClusterInfo&&0===e.chart.pointer.pinchDown.length&&"pan"!==((e.xAxis||{}).eventArgs||{}).trigger&&t&&Object.keys(t).length&&(e.markerClusterInfo.clusters.forEach(function(t){e.animateClusterPoint(t)}),e.markerClusterInfo.noise.forEach(function(t){e.animateClusterPoint(t)})))})}),C(i,"update",function(){if(this.dataGroup)return I("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}),C(o,"destroy",s.prototype.destroyClusteredData),C(o,"afterRender",function(){const e=(this.options.cluster||{}).drillToCluster;this.markerClusterInfo&&this.markerClusterInfo.clusters&&this.markerClusterInfo.clusters.forEach(function(t){t.point&&t.point.graphic&&(t.point.graphic.addClass("highcharts-cluster-point"),e&&t.point&&(t.point.graphic.css({cursor:"pointer"}),t.point.dataLabel&&t.point.dataLabel.css({cursor:"pointer"})),L(t.clusterZone)&&t.point.graphic.addClass(t.clusterZoneClassName||"highcharts-cluster-zone-"+t.clusterZone.zoneIndex))})}),C(i,"drillToCluster",function(t){const e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;M(e)&&e.call(this,t)}),C(l,"setExtremes",function(){let t=this.chart,e=0,a;t.series.forEach(function(t){t.markerClusterInfo&&(a=y((t.options.cluster||{}).animation),e=a.duration||0)}),v(function(){t.tooltip&&t.tooltip.destroy()},e)})}),e(t,"masters/modules/marker-clusters.src.js",[],function(){})});