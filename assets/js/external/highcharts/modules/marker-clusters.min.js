!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(r){"use strict";var t=r?r._modules:{};function e(t,e,i,s){t.hasOwnProperty(e)||(t[e]=s.apply(null,i),"function"==typeof CustomEvent&&r.win.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:e,module:t[e]}})))}e(t,"Extensions/MarkerClusters/MarkerClusterDefaults.js",[],function(){return{cluster:{enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}}}),e(t,"Extensions/MarkerClusters/MarkerClusterScatter.js",[t["Core/Animation/AnimationUtilities.js"],t["Extensions/MarkerClusters/MarkerClusterDefaults.js"],t["Core/Utilities.js"]],function(t,s,e){let Y,y=t["animObject"],E=s["cluster"],{addEvent:D,defined:j,error:S,isArray:b,isFunction:L,isObject:A,isNumber:P,merge:v,objectEach:r,relativeLength:z,syncTimeout:C}=e,a={grid:function(t,e,i,s){let r,a,o,n,l,p={},u=this.getGridOffset(),d=this.getScaledGridSize(s);for(l=0;l<t.length;l++){var h=V(this,{x:t[l],y:e[l]});r=h.x-u.plotLeft,a=h.y-u.plotTop,o=Math.floor(r/d),p[n=Math.floor(a/d)+"-"+o]||(p[n]=[]),p[n].push({dataIndex:i[l],x:t[l],y:e[l]})}return p},kmeans:function(e,i,s,t){let r=[],a=[],o={},n=t.processedDistance||E.layoutAlgorithm.distance,l=t.iterations,p=0,u=!0,d,h,c,f=[];t.processedGridSize=t.processedDistance;var m,g=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,e,i,s,t):{};for(m in g)1<g[m].length&&(c=O(g[m]),r.push({posX:c.x,posY:c.y,oldX:0,oldY:0,startPointsLen:g[m].length,points:[]}));for(;u;){for(var x of r)x.points.length=0;for(let t=a.length=0;t<e.length;t++)d=e[t],h=i[t],((f=this.getClusterDistancesFromPoint(r,d,h)).length&&f[0].distance<n?r[f[0].clusterIndex].points:a).push({x:d,y:h,dataIndex:s[t]});for(let t=0;t<r.length;t++)1===r[t].points.length&&(f=this.getClusterDistancesFromPoint(r,r[t].points[0].x,r[t].points[0].y))[1].distance<n&&(r[f[1].clusterIndex].points.push(r[t].points[0]),r[f[0].clusterIndex].points.length=0);u=!1;for(let t=0;t<r.length;t++)c=O(r[t].points),r[t].oldX=r[t].posX,r[t].oldY=r[t].posY,r[t].posX=c.x,r[t].posY=c.y,(r[t].posX>r[t].oldX+1||r[t].posX<r[t].oldX-1||r[t].posY>r[t].oldY+1||r[t].posY<r[t].oldY-1)&&(u=!0);l&&(u=p<l-1),p++}for(let t=0,e=r.length;t<e;++t)o["cluster"+t]=r[t].points;for(let t=0,e=a.length;t<e;++t)o["noise"+t]=[a[t]];return o},optimizedKmeans:function(t,e,i,s){let r=s.processedDistance||E.layoutAlgorithm.gridSize,a=this.getRealExtremes(),o=(this.options.cluster||{}).marker,n,l={},p,u;if(!this.markerClusterInfo||this.initMaxX&&this.initMaxX<a.maxX||this.initMinX&&this.initMinX>a.minX||this.initMaxY&&this.initMaxY<a.maxY||this.initMinY&&this.initMinY>a.minY)this.initMaxX=a.maxX,this.initMinX=a.minX,this.initMaxY=a.maxY,this.initMinY=a.minY,l=this.markerClusterAlgorithms?this.markerClusterAlgorithms.kmeans.call(this,t,e,i,s):{},this.baseClusters=null;else{for(var d of(this.baseClusters||(this.baseClusters={clusters:this.markerClusterInfo.clusters,noise:this.markerClusterInfo.noise}),this.baseClusters.clusters)){for(var h of(d.pointsOutside=[],d.pointsInside=[],d.data)){var c=V(this,h),f=V(this,d);n=Math.sqrt(Math.pow(c.x-f.x,2)+Math.pow(c.y-f.y,2)),p=0<=r-(u=(d.clusterZone&&d.clusterZone.marker&&d.clusterZone.marker.radius?d.clusterZone.marker:o&&o.radius?o:E.marker).radius)?r-u:u,u+p<n&&j(d.pointsOutside)?d.pointsOutside.push(h):j(d.pointsInside)&&d.pointsInside.push(h)}d.pointsInside.length&&(l[d.id]=d.pointsInside);let t=0;for(var m of d.pointsOutside)l[d.id+"_noise"+t++]=[m]}for(var g of this.baseClusters.noise)l[g.id]=g.data}return l}},l=[],i=0;function o(t,e,i){t.attr({opacity:e}).animate({opacity:1},i)}function k(t,e,i,s){for(var r of(M(t,s,i,!0,!0),e))r.point&&r.point.destroy&&r.point.destroy()}function M(t,e,i,s,r){t.point&&(s&&t.point.graphic&&(t.point.graphic.show(),o(t.point.graphic,e,i)),r&&t.point.dataLabel&&(t.point.dataLabel.show(),o(t.point.dataLabel,e,i)))}function O(e){let i=e.length,s=0,r=0;for(let t=0;t<i;t++)s+=e[t].x,r+=e[t].y;return{x:s/i,y:r/i}}function p(t,e){let i=[];return i.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){i[t.dataIndex]=t})}),t.noise.forEach(function(t){i[t.data[0].dataIndex]=t.data[0]}),i}function X(){return Math.random().toString(36).substring(2,7)+"-"+i++}function I(t,e,i){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),i&&t.point.dataLabel&&t.point.dataLabel.hide())}function w(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(r){let t=r.point||r.target,e=t.series,a=t.series.xAxis,o=t.series.yAxis,n=t.series.chart,{inverted:l,mapView:i,pointer:p}=n;if((e.options.cluster||{}).drillToCluster&&t.clusteredData){var r=t.clusteredData.map(t=>t.x).sort((t,e)=>t-e),s=t.clusteredData.map(t=>t.y).sort((t,e)=>t-e),u=r[0],r=r[r.length-1],d=s[0],s=s[s.length-1],h=Math.abs(.1*(r-u)),c=Math.abs(.1*(s-d)),f=Math.min(u,r)-h,u=Math.max(u,r)+h,r=Math.min(d,s)-c,h=Math.max(d,s)+c;if(i)i.fitToBounds({x1:f,x2:u,y1:r,y2:h});else if(a&&o){let t=a.toPixels(f),e=a.toPixels(u),i=o.toPixels(r),s=o.toPixels(h);l&&([t,e,i,s]=[i,s,t,e]),t>e&&([t,e]=[e,t]),i>s&&([i,s]=[s,i]),p&&(p.zoomX=!0,p.zoomY=!0),n.transform({from:{x:t,y:i,width:e-t,height:s-i}})}}})}function T(t,e){let{chart:i,xAxis:s,yAxis:r}=t;return i.mapView?i.mapView.pixelsToProjectedUnits(e):{x:s?s.toValue(e.x):0,y:r?r.toValue(e.y):0}}function n(t){let e=this.chart,i=e.mapView,s=y((this.options.cluster||{}).animation),r=s.duration||500,a=(this.markerClusterInfo||{}).pointsState,o=(a||{}).newState,n=(a||{}).oldState,l=[],p,u,d,h,c,f,m=!1,g=!1;var x;n&&o&&(x=V(this,u=o[t.stateId]),c=x.x-(i?0:e.plotLeft),f=x.y-(i?0:e.plotTop),1===u.parentsId.length?(p=n[(o||{})[t.stateId].parentsId[0]],u.point&&u.point.graphic&&p&&p.point&&p.point.plotX&&p.point.plotY&&p.point.plotX!==u.point.plotX&&p.point.plotY!==u.point.plotY&&(d=u.point.graphic.getBBox(),h=u.point.graphic&&u.point.graphic.isImg?0:d.width/2,u.point.graphic.attr({x:p.point.plotX-h,y:p.point.plotY-h}),u.point.graphic.animate({x:c-(u.point.graphic.radius||0),y:f-(u.point.graphic.radius||0)},s,function(){g=!0,p.point&&p.point.destroy&&p.point.destroy()}),u.point.dataLabel&&u.point.dataLabel.alignAttr&&p.point.dataLabel&&p.point.dataLabel.alignAttr&&(u.point.dataLabel.attr({x:p.point.dataLabel.alignAttr.x,y:p.point.dataLabel.alignAttr.y}),u.point.dataLabel.animate({x:u.point.dataLabel.alignAttr.x,y:u.point.dataLabel.alignAttr.y},s)))):0===u.parentsId.length?(I(u,!0,!0),C(function(){M(u,.1,s,!0,!0)},r/2)):(I(u,!0,!0),u.parentsId.forEach(function(t){n&&n[t]&&(p=n[t],l.push(p),p.point&&p.point.graphic&&(m=!0,p.point.graphic.show(),p.point.graphic.animate({x:c-(p.point.graphic.radius||0),y:f-(p.point.graphic.radius||0),opacity:.4},s,function(){g=!0,k(u,l,s,.7)}),p.point.dataLabel&&-9999!==p.point.dataLabel.y&&u.point&&u.point.dataLabel&&u.point.dataLabel.alignAttr&&(p.point.dataLabel.show(),p.point.dataLabel.animate({x:u.point.dataLabel.alignAttr.x,y:u.point.dataLabel.alignAttr.y,opacity:.4},s))))}),C(function(){g||k(u,l,s,.85)},r),m||C(function(){k(u,l,s,.1)},r/2)))}function u(){(this.markerClusterSeriesData||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null}function d(){let t,e,i,s,r,a,o,n,l,p,u,d,h,c,f,m,g=this,x=g.chart,y=x.mapView,C=g.xData,k=g.yData,M=g.options.cluster,I=g.getRealExtremes(),S=[],b=[],A=[];if(y&&g.is("mappoint")&&C&&k&&(g.options.data||[]).forEach((t,e)=>{t=g.projectPoint(t);t&&(C[e]=t.x,k[e]=t.y)}),M&&M.enabled&&C&&C.length&&k&&k.length&&!x.polar){u=M.layoutAlgorithm.type,(c=M.layoutAlgorithm).processedGridSize=z(c.gridSize||E.layoutAlgorithm.gridSize,x.plotWidth),c.processedDistance=z(c.distance||E.layoutAlgorithm.distance,x.plotWidth),s=c.kmeansThreshold||E.layoutAlgorithm.kmeansThreshold;var v=c.processedGridSize/2,X=T(g,{x:0,y:0}),v=T(g,{x:v,y:v});for(m=0,r=Math.abs(X.x-v.x),a=Math.abs(X.y-v.y);m<C.length;m++)g.dataMaxX||(j(n)&&j(o)&&j(p)&&j(l)?P(k[m])&&P(p)&&P(l)&&(n=Math.max(C[m],n),o=Math.min(C[m],o),p=Math.max(k[m]||p,p),l=Math.min(k[m]||l,l)):(n=o=C[m],p=l=k[m])),C[m]>=I.minX-r&&C[m]<=I.maxX+r&&(k[m]||I.minY)>=I.minY-a&&(k[m]||I.maxY)<=I.maxY+a&&(S.push(C[m]),b.push(k[m]),A.push(m));j(n)&&j(o)&&P(p)&&P(l)&&(g.dataMaxX=n,g.dataMinX=o,g.dataMaxY=p,g.dataMinY=l),d=(h=(L(u)?u:g.markerClusterAlgorithms?u&&g.markerClusterAlgorithms[u]?g.markerClusterAlgorithms[u]:S.length<s?g.markerClusterAlgorithms.kmeans:g.markerClusterAlgorithms.grid:function(){return!1}).call(this,S,b,A,c))?g.getClusteredData(h,M):h,t=M.animation&&g.markerClusterInfo&&g.markerClusterInfo.pointsState&&g.markerClusterInfo.pointsState.oldState?(function(e){if(e){let t;for(var i of Object.keys(e))(t=e[i]).point&&t.point.destroy&&t.point.destroy()}}(g.markerClusterInfo.pointsState.oldState),g.markerClusterInfo.pointsState.newState):{},e=C.length,i=g.markerClusterInfo,d&&(g.processedXData=d.groupedXData,g.processedYData=d.groupedYData,g.hasGroupedData=!0,g.markerClusterInfo=d,g.groupMap=d.groupMap),Y.apply(this),d&&g.markerClusterInfo&&((g.markerClusterInfo.clusters||[]).forEach(function(t){(f=g.points[t.index]).isCluster=!0,f.clusteredData=t.data,f.clusterPointsAmount=t.data.length,t.point=f,D(f,"click",w)}),(g.markerClusterInfo.noise||[]).forEach(function(t){t.point=g.points[t.index]}),M.animation&&g.markerClusterInfo&&(g.markerClusterInfo.pointsState={oldState:t,newState:g.getPointsState(d,i,e)}),M.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else Y.apply(this)}function h(e,i,s){let r=[];for(let t=0;t<e.length;t++){var a=V(this,{x:i,y:s}),o=V(this,{x:e[t].posX,y:e[t].posY}),a=Math.sqrt(Math.pow(a.x-o.x,2)+Math.pow(a.y-o.y,2));r.push({clusterIndex:t,distance:a})}return r.sort((t,e)=>t.distance-e.distance)}function c(t,e){let i=[],s=[],r=[],a=[],o=[],n=Math.max(2,e.minimumClusterSize||2),l=0,p,u,d,h,c,f,m,g,x,y,C,k,M,I;if(L(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return S("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(I in t)if(t[I].length>=n){if(d=t[I],p=X(),c=d.length,e.zones)for(M=0;M<e.zones.length;M++)c>=e.zones[M].from&&c<=e.zones[M].to&&((C=e.zones[M]).zoneIndex=M,y=e.zones[M].marker,k=e.zones[M].className);for(x=O(d),m="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:x.x,y:x.y}:(f=this.options.marker||{},this.preventClusterCollisions({x:x.x,y:x.y,key:I,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:f.radius||3+(f.lineWidth||0),clusterRadius:y&&y.radius?y.radius:(e.marker||{}).radius||E.marker.radius})),M=0;M<c;M++)d[M].parentStateId=p;if(r.push({x:m.x,y:m.y,id:I,stateId:p,index:l,data:d,clusterZone:C,clusterZoneClassName:k}),i.push(m.x),s.push(m.y),o.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:v(e.marker,{states:e.states},y||{})}}),this.options.data&&this.options.data.length)for(M=0;M<c;M++)A(this.options.data[d[M].dataIndex])&&(d[M].options=this.options.data[d[M].dataIndex]);l++,y=null}else for(M=0;M<t[I].length;M++)u=t[I][M],p=X(),h=((this.options||{}).data||[])[u.dataIndex],i.push(u.x),s.push(u.y),u.parentStateId=p,a.push({x:u.x,y:u.y,id:I,stateId:p,index:l,data:t[I]}),g=h&&"object"==typeof h&&!b(h)?v(h,{x:u.x,y:u.y}):{userOptions:h,x:u.x,y:u.y},o.push({options:g}),l++;return{clusters:r,noise:a,groupedXData:i,groupedYData:s,groupMap:o}}function f(){let t=this.chart,e=this.xAxis,i=this.yAxis;return{plotLeft:e&&this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:i&&this.dataMinY&&this.dataMaxY?i.reversed?i.toPixels(this.dataMinY):i.toPixels(this.dataMaxY):t.plotTop}}function m(t,e,i){var s,r;let a=e?p(e,i):[],o=p(t,i),n={};l=[],t.clusters.forEach(function(t){n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<o.length;t++)s=o[t],r=a[t],s&&r&&s.parentStateId&&r.parentStateId&&n[s.parentStateId]&&-1===n[s.parentStateId].parentsId.indexOf(r.parentStateId)&&(n[s.parentStateId].parentsId.push(r.parentStateId),-1===l.indexOf(r.parentStateId)&&l.push(r.parentStateId));return n}function g(){var t=this.chart,e=t.mapView?0:t.plotLeft,i=T(this,{x:e,y:t.mapView?0:t.plotTop}),e=T(this,{x:e+t.plotWidth,y:e+t.plotHeight}),t=i.x,s=e.x,i=i.y,e=e.y;return{minX:Math.min(t,s),maxX:Math.max(t,s),minY:Math.min(i,e),maxY:Math.max(i,e)}}function x(t){let e=this.xAxis,i=this.chart.mapView,s=t.processedGridSize||E.layoutAlgorithm.gridSize,r=!0,a=1,o=1;this.gridValueSize||(i?this.gridValueSize=s/i.getScale():this.gridValueSize=Math.abs(e.toValue(s)-e.toValue(0)));for(var n=+(s/(i?this.gridValueSize*i.getScale():e.toPixels(this.gridValueSize)-e.toPixels(0))).toFixed(14);r&&1!=n;){var l=Math.pow(2,a);.75<n&&n<1.25?r=!1:1/l<=n&&n<1/l*2?(r=!1,o=l):n<=l&&l/2<n&&(r=!1,o=1/l),a++}return s/o/n}function G(){let t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},i=l.map(t=>(e[t].point||{}).id||"");(t||[]).forEach(function(t){t&&-1!==i.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})}function R(t){let e=!1,i;return!!A(t)&&(r(t,function(t){if(e=!0,b(t)&&t.length){for(i=0;i<t.length;i++)if(!A(t[i])||!t[i].x||!t[i].y)return void(e=!1)}else e=!1}),e)}function F(t){let[e,i]=t.key.split("-").map(parseFloat),s=t.gridSize,r=t.groupedData,a=t.defaultRadius,o=t.clusterRadius,n=i*s,l=e*s,p=V(this,t),u=[],d=(this.options.cluster||{}).marker,h=(this.options.cluster||{}).zones,c=this.getGridOffset(),f=p.x,m=p.y,g,x=0,y,C,k,M,I,S,b,A,v,X,Y,D,L;for(f-=c.plotLeft,m-=c.plotTop,b=1;b<5;b++)for(A=0,k=b%2?-1:1,M=b<3?-1:1,I=Math.floor((f+k*o)/s),L=[(S=Math.floor((m+M*o)/s))+"-"+I,S+"-"+i,e+"-"+I];A<L.length;A++)-1===u.indexOf(L[A])&&L[A]!==t.key&&u.push(L[A]);for(var P of u)if(r[P]){r[P].posX||(Y=O(r[P]),r[P].posX=Y.x,r[P].posY=Y.y);var z=V(this,{x:r[P].posX||0,y:r[P].posY||0});if(y=z.x-c.plotLeft,C=z.y-c.plotTop,[X,v]=P.split("-").map(parseFloat),h)for(b=0,g=r[P].length;b<h.length;b++)g>=h[b].from&&g<=h[b].to&&(x=j((h[b].marker||{}).radius)?h[b].marker.radius||0:(d&&d.radius?d:E.marker).radius);1<r[P].length&&0===x&&d&&d.radius?x=d.radius:1===r[P].length&&(x=a),D=o+x,x=0,v!==i&&Math.abs(f-y)<D&&(f=v-i<0?n+o:n+s-o),X!==e&&Math.abs(m-C)<D&&(m=X-e<0?l+o:l+s-o)}var w=T(this,{x:f+c.plotLeft,y:m+c.plotTop});return r[t.key].posX=w.x,r[t.key].posY=w.y,w}function V(t,e){let{chart:i,xAxis:s,yAxis:r}=t;return i.mapView?i.mapView.projectedUnitsToPixels(e):{x:s?s.toPixels(e.x):0,y:r?r.toPixels(e.y):0}}return{compose:function(t,e){let i=e.prototype;i.markerClusterAlgorithms||(Y=i.generatePoints,i.markerClusterAlgorithms=a,i.animateClusterPoint=n,i.destroyClusteredData=u,i.generatePoints=d,i.getClusterDistancesFromPoint=h,i.getClusteredData=c,i.getGridOffset=f,i.getPointsState=m,i.getRealExtremes=g,i.getScaledGridSize=x,i.hideClusteredData=G,i.isValidGroupedDataObject=R,i.preventClusterCollisions=F,D(e,"destroy",i.destroyClusteredData),(t.plotOptions||{}).series=v((t.plotOptions||{}).series,s))}}}),e(t,"Extensions/MarkerClusters/MarkerClusters.js",[t["Core/Animation/AnimationUtilities.js"],t["Core/Defaults.js"],t["Core/Globals.js"],t["Extensions/MarkerClusters/MarkerClusterDefaults.js"],t["Extensions/MarkerClusters/MarkerClusterScatter.js"],t["Core/Utilities.js"]],function(t,e,i,s,o,r){let a=t["animObject"],n=e["defaultOptions"],l=i["composed"],{addEvent:p,defined:u,error:d,isFunction:h,merge:c,pushUnique:f,syncTimeout:m}=r;function g(){let t=this.chart,e=0;for(var i of t.series)i.markerClusterInfo&&(e=a((i.options.cluster||{}).animation).duration||0);m(()=>{t.tooltip&&t.tooltip.destroy()},e)}function x(){for(var t of this.series||[])if(t.markerClusterInfo){var e=t.options.cluster,i=((t.markerClusterInfo||{}).pointsState||{}).oldState;if((e||{}).animation&&t.markerClusterInfo&&0===(t.chart.pointer?.pinchDown||[]).length&&"pan"!==((t.xAxis||{}).eventArgs||{}).trigger&&i&&Object.keys(i).length){for(var s of t.markerClusterInfo.clusters)t.animateClusterPoint(s);for(var r of t.markerClusterInfo.noise)t.animateClusterPoint(r)}}}function y(t){let e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;h(e)&&e.call(this,t)}function C(){if(this.dataGroup)return d("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}function k(){var t=(this.options.cluster||{}).drillToCluster;if(this.markerClusterInfo&&this.markerClusterInfo.clusters)for(var e of this.markerClusterInfo.clusters)e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),u(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))}return(n.plotOptions||{}).series=c((n.plotOptions||{}).series,s),{compose:function(t,e,i,s){var r,a;f(l,"MarkerClusters")&&(r=s.prototype.pointClass,a=s.types["scatter"],p(t,"setExtremes",g),p(e,"render",x),p(r,"drillToCluster",y),p(r,"update",C),p(s,"afterRender",k),a&&o.compose(i,a))}}}),e(t,"Extensions/MarkerClusters/MarkerClusterSymbols.js",[],function(){let o;function e(t,e,i,s){var i=i/2,s=s/2,r=o.arc(t+i,e+s,i-4,s-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),a=o.arc(t+i,e+s,i-3,s-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:i-2,open:!1});return o.arc(t+i,e+s,i-1,s-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:i,open:!1}).concat(a,r)}return{compose:function(t){(o=t.prototype.symbols).cluster=e}}}),e(t,"masters/modules/marker-clusters.src.js",[t["Core/Globals.js"],t["Extensions/MarkerClusters/MarkerClusters.js"],t["Extensions/MarkerClusters/MarkerClusterSymbols.js"]],function(t,e,i){return e.compose(t.Axis,t.Chart,t.defaultOptions,t.Series),i.compose(t.SVGRenderer),t})});