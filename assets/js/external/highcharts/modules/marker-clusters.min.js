!function(e){"object"==typeof module&&module.exports?module.exports=e.default=e:"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts"],function(t){return e(t),e.Highcharts=t,e}):e("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){function e(t,e,a,i){t.hasOwnProperty(e)||(t[e]=i.apply(null,a),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:e,module:t[e]}})))}e(t=t?t._modules:{},"Extensions/MarkerClusters.js",[t["Core/Animation/AnimationUtilities.js"],t["Core/Chart/Chart.js"],t["Core/Defaults.js"],t["Core/Series/Point.js"],t["Core/Series/Series.js"],t["Core/Series/SeriesRegistry.js"],t["Core/Renderer/SVG/SVGRenderer.js"],t["Core/Utilities.js"],t["Core/Axis/Axis.js"]],function(t,e,a,i,r,o,n,s,l){function v(t){for(var e=t.length,a=0,i=0,r=0;r<e;r++)a+=t[r].x,i+=t[r].y;return{x:a/e,y:i/e}}function p(t,e){var a=[];return a.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){a[t.dataIndex]=t})}),t.noise.forEach(function(t){a[t.data[0].dataIndex]=t.data[0]}),a}function f(t,e,a,i,r){t.point&&(i&&t.point.graphic&&(t.point.graphic.show(),t.point.graphic.attr({opacity:e}).animate({opacity:1},a)),r&&t.point.dataLabel&&(t.point.dataLabel.show(),t.point.dataLabel.attr({opacity:e}).animate({opacity:1},a)))}function g(t,e,a){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),a&&t.point.dataLabel&&t.point.dataLabel.hide())}function x(t,e,a,i){f(t,i,a,!0,!0),e.forEach(function(t){t.point&&t.point.destroy&&t.point.destroy()})}function X(t,e){var a=t.chart,i=t.xAxis;return t=t.yAxis,a.mapView?a.mapView.pixelsToProjectedUnits(e):{x:i?i.toValue(e.x):0,y:t?t.toValue(e.y):0}}function Y(t,e){var a=t.chart,i=t.xAxis;return t=t.yAxis,a.mapView?a.mapView.projectedUnitsToPixels(e):{x:i?i.toPixels(e.x):0,y:t?t.toPixels(e.y):0}}var y=t.animObject,u=(t=a.defaultOptions,o=o.seriesTypes,n.prototype.symbols),C=s.addEvent,L=s.defined,I=s.error,k=s.isArray,M=s.isFunction,S=s.isObject,b=s.isNumber,A=s.merge,D=s.objectEach,E=s.relativeLength,P=s.syncTimeout,z=(n=o.scatter,r.prototype.generatePoints),d=[],w=0,T={enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}};(t.plotOptions||{}).series=A((t.plotOptions||{}).series,{cluster:T,tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}});u.cluster=function(t,e,a,i){var r=u.arc(t+(a/=2),e+(i/=2),a-4,i-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),o=u.arc(t+a,e+i,a-3,i-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a-2,open:!1});return u.arc(t+a,e+i,a-1,i-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:a,open:!1}).concat(o,r)},n.prototype.animateClusterPoint=function(t){var e,a,i=this.chart,r=i.mapView,o=y((this.options.cluster||{}).animation),n=o.duration||500,s=(this.markerClusterInfo||{}).pointsState,l=(s||{}).newState,p=(s||{}).oldState,u=[],d=0,h=0,c=!1,m=!1;p&&l&&(e=l[t.stateId],d=(s=Y(this,e)).x-(r?0:i.plotLeft),h=s.y-(r?0:i.plotTop),1===e.parentsId.length?(t=(l||{})[t.stateId].parentsId[0],a=p[t],e.point&&e.point.graphic&&a&&a.point&&a.point.plotX&&a.point.plotY&&a.point.plotX!==e.point.plotX&&a.point.plotY!==e.point.plotY&&(t=e.point.graphic.getBBox(),s=e.point.graphic&&e.point.graphic.isImg?0:t.width/2,e.point.graphic.attr({x:a.point.plotX-s,y:a.point.plotY-s}),e.point.graphic.animate({x:d-(e.point.graphic.radius||0),y:h-(e.point.graphic.radius||0)},o,function(){m=!0,a.point&&a.point.destroy&&a.point.destroy()}),e.point.dataLabel&&e.point.dataLabel.alignAttr&&a.point.dataLabel&&a.point.dataLabel.alignAttr&&(e.point.dataLabel.attr({x:a.point.dataLabel.alignAttr.x,y:a.point.dataLabel.alignAttr.y}),e.point.dataLabel.animate({x:e.point.dataLabel.alignAttr.x,y:e.point.dataLabel.alignAttr.y},o)))):0===e.parentsId.length?(g(e,!0,!0),P(function(){f(e,.1,o,!0,!0)},n/2)):(g(e,!0,!0),e.parentsId.forEach(function(t){p&&p[t]&&(a=p[t],u.push(a),a.point&&a.point.graphic&&(c=!0,a.point.graphic.show(),a.point.graphic.animate({x:d-(a.point.graphic.radius||0),y:h-(a.point.graphic.radius||0),opacity:.4},o,function(){m=!0,x(e,u,o,.7)}),a.point.dataLabel&&-9999!==a.point.dataLabel.y&&e.point&&e.point.dataLabel&&e.point.dataLabel.alignAttr&&(a.point.dataLabel.show(),a.point.dataLabel.animate({x:e.point.dataLabel.alignAttr.x,y:e.point.dataLabel.alignAttr.y,opacity:.4},o))))}),P(function(){m||x(e,u,o,.85)},n),c||P(function(){x(e,u,o,.1)},n/2)))},n.prototype.getGridOffset=function(){var t=this.chart,e=this.xAxis,a=this.yAxis;return{plotLeft:e=e&&this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:t=a&&this.dataMinY&&this.dataMaxY?a.reversed?a.toPixels(this.dataMinY):a.toPixels(this.dataMaxY):t.plotTop}},n.prototype.getScaledGridSize=function(t){var e=this.xAxis,a=this.chart.mapView,i=(t=t.processedGridSize||T.layoutAlgorithm.gridSize,!0),r=1,o=1;for(this.gridValueSize||(this.gridValueSize=a?t/a.getScale():Math.abs(e.toValue(t)-e.toValue(0))),e=+(t/(e=a?this.gridValueSize*a.getScale():e.toPixels(this.gridValueSize)-e.toPixels(0))).toFixed(14);i&&1!==e;)a=Math.pow(2,r),.75<e&&e<1.25?i=!1:1/a<=e&&e<1/a*2?(i=!1,o=a):e<=a&&a/2<e&&(i=!1,o=1/a),r++;return t/o/e},n.prototype.getRealExtremes=function(){var t=(i=this.chart).mapView?0:i.plotLeft,e=X(this,{x:t,y:i.mapView?0:i.plotTop}),a=X(this,{x:t+i.plotWidth,y:t+i.plotHeight}),i=e.x,t=a.x,e=e.y,a=a.y;return{minX:Math.min(i,t),maxX:Math.max(i,t),minY:Math.min(e,a),maxY:Math.max(e,a)}},n.prototype.onDrillToCluster=function(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){var e,a,i,r,o,n,s=t.point||t.target,l=s.series.xAxis,p=s.series.yAxis,u=s.series.chart,d=u.mapView;(s.series.options.cluster||{}).drillToCluster&&s.clusteredData&&(i=s.clusteredData.map(function(t){return t.x}).sort(function(t,e){return t-e}),s=s.clusteredData.map(function(t){return t.y}).sort(function(t,e){return t-e}),e=i[0],a=i[i.length-1],i=s[0],r=s[s.length-1],o=Math.abs(.1*(a-e)),n=Math.abs(.1*(r-i)),s=Math.min(e,a)-o,e=Math.max(e,a)+o,a=Math.min(i,r)-n,i=Math.max(i,r)+n,d?d.fitToBounds({x1:s,x2:e,y1:a,y2:i}):l&&p&&(u.pointer.zoomX=!0,u.pointer.zoomY=!0,u.zoom({originalEvent:t,xAxis:[{axis:l,min:s,max:e}],yAxis:[{axis:p,min:a,max:i}]})))})},n.prototype.getClusterDistancesFromPoint=function(t,e,a){for(var i=[],r=0;r<t.length;r++){var o=Y(this,{x:e,y:a}),n=Y(this,{x:t[r].posX,y:t[r].posY});i.push({clusterIndex:r,distance:Math.sqrt(Math.pow(o.x-n.x,2)+Math.pow(o.y-n.y,2))})}return i.sort(function(t,e){return t.distance-e.distance})},n.prototype.getPointsState=function(t,e,a){e=e?p(e,a):[],a=p(t,a);var i,r={};for(d=[],t.clusters.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(function(t){r[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),i=0;i<a.length;i++){t=a[i];var o=e[i];t&&o&&t.parentStateId&&o.parentStateId&&r[t.parentStateId]&&-1===r[t.parentStateId].parentsId.indexOf(o.parentStateId)&&(r[t.parentStateId].parentsId.push(o.parentStateId),-1===d.indexOf(o.parentStateId)&&d.push(o.parentStateId))}return r},n.prototype.markerClusterAlgorithms={grid:function(t,e,a,i){var r={},o=this.getGridOffset(),n=this.getScaledGridSize(i);for(i=0;i<t.length;i++){var s=(l=Y(this,{x:t[i],y:e[i]})).x-o.plotLeft,l=l.y-o.plotTop,s=Math.floor(s/n);r[s=Math.floor(l/n)+"-"+s]||(r[s]=[]),r[s].push({dataIndex:a[i],x:t[i],y:e[i]})}return r},kmeans:function(t,e,a,i){var r,o,n=[],s=[],l={},p=i.processedDistance||T.layoutAlgorithm.distance,u=i.iterations,d=0,h=!0,c=0,m=[];for(o in i.processedGridSize=i.processedDistance,c=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,t,e,a,i):{})1<c[o].length&&(m=v(c[o]),n.push({posX:m.x,posY:m.y,oldX:0,oldY:0,startPointsLen:c[o].length,points:[]}));for(;h;){for(n.map(function(t){return t.points.length=0,t}),h=s.length=0;h<t.length;h++)c=t[h],r=e[h],((m=this.getClusterDistancesFromPoint(n,c,r)).length&&m[0].distance<p?n[m[0].clusterIndex].points:s).push({x:c,y:r,dataIndex:a[h]});for(o=0;o<n.length;o++)1===n[o].points.length&&((m=this.getClusterDistancesFromPoint(n,n[o].points[0].x,n[o].points[0].y))[1].distance<p&&(n[m[1].clusterIndex].points.push(n[o].points[0]),n[m[0].clusterIndex].points.length=0));for(h=!1,o=0;o<n.length;o++)m=v(n[o].points),n[o].oldX=n[o].posX,n[o].oldY=n[o].posY,n[o].posX=m.x,n[o].posY=m.y,(n[o].posX>n[o].oldX+1||n[o].posX<n[o].oldX-1||n[o].posY>n[o].oldY+1||n[o].posY<n[o].oldY-1)&&(h=!0);u&&(h=d<u-1),d++}return n.forEach(function(t,e){l["cluster"+e]=t.points}),s.forEach(function(t,e){l["noise"+e]=[t]}),l},optimizedKmeans:function(t,e,a,i){var r,o,n=this,s=i.processedDistance||T.layoutAlgorithm.gridSize,l={},p=n.getRealExtremes(),u=(n.options.cluster||{}).marker;return!n.markerClusterInfo||n.initMaxX&&n.initMaxX<p.maxX||n.initMinX&&n.initMinX>p.minX||n.initMaxY&&n.initMaxY<p.maxY||n.initMinY&&n.initMinY>p.minY?(n.initMaxX=p.maxX,n.initMinX=p.minX,n.initMaxY=p.maxY,n.initMinY=p.minY,l=n.markerClusterAlgorithms?n.markerClusterAlgorithms.kmeans.call(n,t,e,a,i):{},n.baseClusters=null):(n.baseClusters||(n.baseClusters={clusters:n.markerClusterInfo.clusters,noise:n.markerClusterInfo.noise}),n.baseClusters.clusters.forEach(function(i){i.pointsOutside=[],i.pointsInside=[],i.data.forEach(function(t){var e=Y(n,t),a=Y(n,i);r=Math.sqrt(Math.pow(e.x-a.x,2)+Math.pow(e.y-a.y,2)),(o=(i.clusterZone&&i.clusterZone.marker&&i.clusterZone.marker.radius?i.clusterZone.marker:u&&u.radius?u:T.marker).radius)+(0<=s-o?s-o:o)<r&&L(i.pointsOutside)?i.pointsOutside.push(t):L(i.pointsInside)&&i.pointsInside.push(t)}),i.pointsInside.length&&(l[i.id]=i.pointsInside),i.pointsOutside.forEach(function(t,e){l[i.id+"_noise"+e]=[t]})}),n.baseClusters.noise.forEach(function(t){l[t.id]=t.data})),l}},n.prototype.preventClusterCollisions=function(t){var a,i,r,o,n,s,l,p=this,e=t.key.split("-").map(parseFloat),u=e[0],d=e[1],h=t.gridSize,c=t.groupedData,m=t.defaultRadius,f=t.clusterRadius,g=d*h,x=u*h,y=(e=Y(p,t)).x,C=e.y,I=(e=[],0),k=(p.options.cluster||{}).marker,M=(p.options.cluster||{}).zones,S=p.getGridOffset();for(y-=S.plotLeft,C-=S.plotTop,r=1;r<5;r++){var b=r%2?-1:1,A=r<3?-1:1,b=Math.floor((y+b*f)/h);for(b=[(A=Math.floor((C+A*f)/h))+"-"+b,A+"-"+d,u+"-"+b],A=0;A<b.length;A++)-1===e.indexOf(b[A])&&b[A]!==t.key&&e.push(b[A])}return e.forEach(function(t){if(c[t]){c[t].posX||(s=v(c[t]),c[t].posX=s.x,c[t].posY=s.y);var e=Y(p,{x:c[t].posX||0,y:c[t].posY||0});if(s=e.x-S.plotLeft,i=e.y-S.plotTop,e=t.split("-").map(parseFloat),n=e[0],o=e[1],M)for(a=c[t].length,r=0;r<M.length;r++)a>=M[r].from&&a<=M[r].to&&(I=L((M[r].marker||{}).radius)?M[r].marker.radius||0:(k&&k.radius?k:T.marker).radius);1<c[t].length&&0===I&&k&&k.radius?I=k.radius:1===c[t].length&&(I=m),l=f+I,I=0,o!==d&&Math.abs(y-s)<l&&(y=o-d<0?g+f:g+h-f),n!==u&&Math.abs(C-i)<l&&(C=n-u<0?x+f:x+h-f)}}),e=X(p,{x:y+S.plotLeft,y:C+S.plotTop}),c[t.key].posX=e.x,c[t.key].posY=e.y,e},n.prototype.isValidGroupedDataObject=function(t){var e,a=!1;return!!S(t)&&(D(t,function(t){if(a=!0,k(t)&&t.length){for(e=0;e<t.length;e++)if(!S(t[e])||!t[e].x||!t[e].y){a=!1;break}}else a=!1}),a)},n.prototype.getClusteredData=function(t,e){var a,i=[],r=[],o=[],n=[],s=[],l=0,p=Math.max(2,e.minimumClusterSize||2);if(M(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return I("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(a in t)if(t[a].length>=p){var u,d,h,c=t[a],m=Math.random().toString(36).substring(2,7)+"-"+w++,f=c.length;if(e.zones)for(x=0;x<e.zones.length;x++)f>=e.zones[x].from&&f<=e.zones[x].to&&((u=e.zones[x]).zoneIndex=x,d=e.zones[x].marker,h=e.zones[x].className);for(var g=v(c),g="grid"!==e.layoutAlgorithm.type||e.allowOverlap?{x:g.x,y:g.y}:(x=this.options.marker||{},this.preventClusterCollisions({x:g.x,y:g.y,key:a,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:x.radius||3+(x.lineWidth||0),clusterRadius:d&&d.radius?d.radius:(e.marker||{}).radius||T.marker.radius})),x=0;x<f;x++)c[x].parentStateId=m;if(o.push({x:g.x,y:g.y,id:a,stateId:m,index:l,data:c,clusterZone:u,clusterZoneClassName:h}),i.push(g.x),r.push(g.y),s.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:A(e.marker,{states:e.states},d||{})}}),this.options.data&&this.options.data.length)for(x=0;x<f;x++)S(this.options.data[c[x].dataIndex])&&(c[x].options=this.options.data[c[x].dataIndex]);l++,d=null}else for(x=0;x<t[a].length;x++)c=t[a][x],m=Math.random().toString(36).substring(2,7)+"-"+w++,f=((this.options||{}).data||[])[c.dataIndex],i.push(c.x),r.push(c.y),c.parentStateId=m,n.push({x:c.x,y:c.y,id:a,stateId:m,index:l,data:t[a]}),m=f&&"object"==typeof f&&!k(f)?A(f,{x:c.x,y:c.y}):{userOptions:f,x:c.x,y:c.y},s.push({options:m}),l++;return{clusters:o,noise:n,groupedXData:i,groupedYData:r,groupMap:s}},n.prototype.destroyClusteredData=function(){(this.markerClusterSeriesData||[]).forEach(function(t){t&&t.destroy&&t.destroy()}),this.markerClusterSeriesData=null},n.prototype.hideClusteredData=function(){var t=this.markerClusterSeriesData,e=((this.markerClusterInfo||{}).pointsState||{}).oldState||{},a=d.map(function(t){return(e[t].point||{}).id||""});(t||[]).forEach(function(t){t&&-1!==a.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t&&t.destroy&&t.destroy()})},n.prototype.generatePoints=function(){var t,e,a,i=this,r=(f=i.chart).mapView,o=i.xData,n=i.yData,s=i.options.cluster,l=i.getRealExtremes(),p=[],u=[],d=[];if(r&&i.is("mappoint")&&o&&n&&(i.options.data||[]).forEach(function(t,e){(t=i.projectPoint(t))&&(o[e]=t.x,n[e]=t.y)}),s&&s.enabled&&o&&o.length&&n&&n.length&&!f.polar){for(var h,c,m=s.layoutAlgorithm.type,f=((r=s.layoutAlgorithm).processedGridSize=E(r.gridSize||T.layoutAlgorithm.gridSize,f.plotWidth),r.processedDistance=E(r.distance||T.layoutAlgorithm.distance,f.plotWidth),r.kmeansThreshold||T.layoutAlgorithm.kmeansThreshold),g=r.processedGridSize/2,x=X(i,{x:0,y:0}),y=X(i,{x:g,y:g}),g=Math.abs(x.x-y.x),x=Math.abs(x.y-y.y),y=0;y<o.length;y++)i.dataMaxX||(L(h)&&L(t)&&L(c)&&L(e)?b(n[y])&&b(c)&&b(e)&&(h=Math.max(o[y],h),t=Math.min(o[y],t),c=Math.max(n[y]||c,c),e=Math.min(n[y]||e,e)):(h=t=o[y],c=e=n[y])),o[y]>=l.minX-g&&o[y]<=l.maxX+g&&(n[y]||l.minY)>=l.minY-x&&(n[y]||l.maxY)<=l.maxY+x&&(p.push(o[y]),u.push(n[y]),d.push(y));L(h)&&L(t)&&b(c)&&b(e)&&(i.dataMaxX=h,i.dataMinX=t,i.dataMaxY=c,i.dataMinY=e),l=(p=(l=M(m)?m:i.markerClusterAlgorithms?m&&i.markerClusterAlgorithms[m]?i.markerClusterAlgorithms[m]:p.length<f?i.markerClusterAlgorithms.kmeans:i.markerClusterAlgorithms.grid:function(){return!1}).call(this,p,u,d,r))?i.getClusteredData(p,s):p,p=s.animation&&i.markerClusterInfo&&i.markerClusterInfo.pointsState&&i.markerClusterInfo.pointsState.oldState?((m=i.markerClusterInfo.pointsState.oldState)&&D(m,function(t){t.point&&t.point.destroy&&t.point.destroy()}),i.markerClusterInfo.pointsState.newState):{},u=o.length,d=i.markerClusterInfo,l&&(i.processedXData=l.groupedXData,i.processedYData=l.groupedYData,i.hasGroupedData=!0,i.markerClusterInfo=l,i.groupMap=l.groupMap),z.apply(this),l&&i.markerClusterInfo&&((i.markerClusterInfo.clusters||[]).forEach(function(t){(a=i.points[t.index]).isCluster=!0,a.clusteredData=t.data,a.clusterPointsAmount=t.data.length,t.point=a,C(a,"click",i.onDrillToCluster)}),(i.markerClusterInfo.noise||[]).forEach(function(t){t.point=i.points[t.index]}),s.animation&&i.markerClusterInfo&&(i.markerClusterInfo.pointsState={oldState:p,newState:i.getPointsState(l,d,u)}),s.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else z.apply(this)},C(e,"render",function(){(this.series||[]).forEach(function(e){var t;e.markerClusterInfo&&(t=((e.markerClusterInfo||{}).pointsState||{}).oldState,(e.options.cluster||{}).animation&&e.markerClusterInfo&&0===e.chart.pointer.pinchDown.length&&"pan"!==((e.xAxis||{}).eventArgs||{}).trigger&&t&&Object.keys(t).length&&(e.markerClusterInfo.clusters.forEach(function(t){e.animateClusterPoint(t)}),e.markerClusterInfo.noise.forEach(function(t){e.animateClusterPoint(t)})))})}),C(i,"update",function(){if(this.dataGroup)return I("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}),C(r,"destroy",n.prototype.destroyClusteredData),C(r,"afterRender",function(){var e=(this.options.cluster||{}).drillToCluster;this.markerClusterInfo&&this.markerClusterInfo.clusters&&this.markerClusterInfo.clusters.forEach(function(t){t.point&&t.point.graphic&&(t.point.graphic.addClass("highcharts-cluster-point"),e&&t.point&&(t.point.graphic.css({cursor:"pointer"}),t.point.dataLabel&&t.point.dataLabel.css({cursor:"pointer"})),L(t.clusterZone)&&t.point.graphic.addClass(t.clusterZoneClassName||"highcharts-cluster-zone-"+t.clusterZone.zoneIndex))})}),C(i,"drillToCluster",function(t){var e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;M(e)&&e.call(this,t)}),C(l,"setExtremes",function(){var e,t=this.chart,a=0;t.series.forEach(function(t){t.markerClusterInfo&&(e=y((t.options.cluster||{}).animation),a=e.duration||0)}),P(function(){t.tooltip&&t.tooltip.destroy()},a)})}),e(t,"masters/modules/marker-clusters.src.js",[],function(){})});