"use strict";!function(n){"object"==typeof module&&module.exports?module.exports=n.default=n:"function"==typeof define&&define.amd?define("highcharts/modules/pathfinder",["highcharts"],function(t){return n(t),n.Highcharts=t,n}):n("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){function n(t,n,i,e){t.hasOwnProperty(n)||(t[n]=e.apply(null,i),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:n,module:t[n]}})))}n(t=t?t._modules:{},"Gantt/Connection.js",[t["Core/Defaults.js"],t["Core/Globals.js"],t["Core/Series/Point.js"],t["Core/Utilities.js"]],function(t,n,i,e){function p(t){var n=t.shapeArgs;return n?{xMin:n.x||0,xMax:(n.x||0)+(n.width||0),yMin:n.y||0,yMax:(n.y||0)+(n.height||0)}:(n=t.graphic&&t.graphic.getBBox())?{xMin:t.plotX-n.width/2,xMax:t.plotX+n.width/2,yMin:t.plotY-n.height/2,yMax:t.plotY+n.height/2}:null}t=t.defaultOptions;const{defined:o,error:a,extend:r,merge:s,objectEach:h}=e,c=n.deg2rad,x=Math.max,l=Math.min;r(t,{connectors:{type:"straight",lineWidth:1,marker:{enabled:!1,align:"center",verticalAlign:"middle",inside:!1,lineWidth:1},startMarker:{symbol:"diamond"},endMarker:{symbol:"arrow-filled"}}});class M{constructor(t,n,i){this.toPoint=this.pathfinder=this.graphics=this.fromPoint=this.chart=void 0,this.init(t,n,i)}init(t,n,i){this.fromPoint=t,this.toPoint=n,this.options=i,this.chart=t.series.chart,this.pathfinder=this.chart.pathfinder}renderPath(t,n,i){let e=this.chart,r=e.styledMode,a=e.pathfinder,o=!e.options.chart.forExport&&!1!==i,s=this.graphics&&this.graphics.path;a.group||(a.group=e.renderer.g().addClass("highcharts-pathfinder-group").attr({zIndex:-1}).add(e.seriesGroup)),a.group.translate(e.plotLeft,e.plotTop),s&&s.renderer||(s=e.renderer.path().add(a.group),r||s.attr({opacity:0})),s.attr(n),t={d:t},r||(t.opacity=1),s[o?"animate":"attr"](t,i),this.graphics=this.graphics||{},this.graphics.path=s}addMarker(t,n,i){var e=(r=this.fromPoint.series.chart).pathfinder,r=r.renderer;let a="start"===t?this.fromPoint:this.toPoint;var o=a.getPathfinderAnchorPoint(n);let s,h;n.enabled&&((i="start"===t?i[1]:i[i.length-2])&&"M"===i[0]||"L"===i[0])&&(i={x:i[1],y:i[2]},i=a.getRadiansToVector(i,o),o=a.getMarkerVector(i,n.radius,o),i=-i/c,n.width&&n.height?(s=n.width,h=n.height):s=h=2*n.radius,this.graphics=this.graphics||{},o={x:o.x-s/2,y:o.y-h/2,width:s,height:h,rotation:i,rotationOriginX:o.x,rotationOriginY:o.y},this.graphics[t]?this.graphics[t].animate(o):(this.graphics[t]=r.symbol(n.symbol).addClass("highcharts-point-connecting-path-"+t+"-marker").attr(o).add(e.group),r.styledMode||this.graphics[t].attr({fill:n.color||this.fromPoint.color,stroke:n.lineColor,"stroke-width":n.lineWidth,opacity:0}).animate({opacity:1},a.series.options.animation)))}getPath(t){let n=this.pathfinder,i=this.chart,e=n.algorithms[t.type],r=n.chartObstacles;return"function"!=typeof e?(a('"'+t.type+'" is not a Pathfinder algorithm.'),{path:[],obstacles:[]}):(e.requiresObstacles&&!r&&(r=n.chartObstacles=n.getChartObstacles(t),i.options.connectors.algorithmMargin=t.algorithmMargin,n.chartObstacleMetrics=n.getObstacleMetrics(r)),e(this.fromPoint.getPathfinderAnchorPoint(t.startMarker),this.toPoint.getPathfinderAnchorPoint(t.endMarker),s({chartObstacles:r,lineObstacles:n.lineObstacles||[],obstacleMetrics:n.chartObstacleMetrics,hardBounds:{xMin:0,xMax:i.plotWidth,yMin:0,yMax:i.plotHeight},obstacleOptions:{margin:t.algorithmMargin},startDirectionX:n.getAlgorithmStartDirection(t.startMarker)},t)))}render(){var t=this.fromPoint,n=t.series,i=n.chart;let e=i.pathfinder,r=s(i.options.connectors,n.options.connectors,t.options.connectors,this.options),a={};i.styledMode||(a.stroke=r.lineColor||t.color,a["stroke-width"]=r.lineWidth,r.dashStyle&&(a.dashstyle=r.dashStyle)),a.class="highcharts-point-connecting-path highcharts-color-"+t.colorIndex,r=s(a,r),o(r.marker.radius)||(r.marker.radius=l(x(Math.ceil((r.algorithmMargin||8)/2)-1,1),5)),i=(t=this.getPath(r)).path,t.obstacles&&(e.lineObstacles=e.lineObstacles||[],e.lineObstacles=e.lineObstacles.concat(t.obstacles)),this.renderPath(i,a,n.options.animation),this.addMarker("start",s(r.marker,r.startMarker),i),this.addMarker("end",s(r.marker,r.endMarker),i)}destroy(){this.graphics&&(h(this.graphics,function(t){t.destroy()}),delete this.graphics)}}return n.Connection=M,r(i.prototype,{getPathfinderAnchorPoint:function(t){let n=p(this),i,e;switch(t.align){case"right":i="xMax";break;case"left":i="xMin"}switch(t.verticalAlign){case"top":e="yMin";break;case"bottom":e="yMax"}return{x:i?n[i]:(n.xMin+n.xMax)/2,y:e?n[e]:(n.yMin+n.yMax)/2}},getRadiansToVector:function(t,n){var i;return o(n)||(i=p(this))&&(n={x:(i.xMin+i.xMax)/2,y:(i.yMin+i.yMax)/2}),Math.atan2(n.y-t.y,t.x-n.x)},getMarkerVector:function(t,n,i){var e=2*Math.PI,r=p(this),a=r.xMax-r.xMin;let o=r.yMax-r.yMin,s=Math.atan2(o,a),h=!1;var c=o/2,x=r.xMin+(a/=2),l=x,M=r=r.yMin+c;let d=1,y=1;for(;t<-Math.PI;)t+=e;for(;t>Math.PI;)t-=e;return e=Math.tan(t),-s<t&&t<=s?(y=-1,h=!0):s<t&&t<=Math.PI-s?y=-1:t>Math.PI-s||t<=-(Math.PI-s)?(d=-1,h=!0):d=-1,h?(l+=d*a,M+=y*a*e):(l+=o/(2*e)*d,M+=y*c),i.x!==x&&(l=i.x),i.y!==r&&(M=i.y),{x:l+n*Math.cos(t),y:M-n*Math.sin(t)}}}),M}),n(t,"Gantt/PathfinderAlgorithms.js",[t["Core/Utilities.js"]],function(t){function v(t,n,i){i=i||0;let e=t.length-1;var r,a;for(n-=1e-7;i<=e;)if(0<(a=n-t[r=e+i>>1].xMin))i=1+r;else{if(!(a<0))return r;e=r-1}return 0<i?i-1:0}function P(t,n){let i=v(t,n.x+1)+1;for(;i--;){var e;if((e=t[i].xMax>=n.x)&&(e=t[i],e=n.x<=e.xMax&&n.x>=e.xMin&&n.y<=e.yMax&&n.y>=e.yMin),e)return i}return-1}function k(n){const i=[];if(n.length){i.push(["M",n[0].start.x,n[0].start.y]);for(let t=0;t<n.length;++t)i.push(["L",n[t].end.x,n[t].end.y])}return i}function O(t,n){t.yMin=j(t.yMin,n.yMin),t.yMax=C(t.yMax,n.yMax),t.xMin=j(t.xMin,n.xMin),t.xMax=C(t.xMax,n.xMax)}const w=t["pick"],{min:C,max:j,abs:A}=Math;(t=function(t,n,i){function r(t,n,i,e,r){return(t={x:t.x,y:t.y})[n]=i[e||n]+(r||0),t}function e(t,n,i){var e=A(n[i]-t[i+"Min"])>A(n[i]-t[i+"Max"]);return r(n,i,t,i+(e?"Max":"Min"),e?1:-1)}let a=[];var o,s=w(i.startDirectionX,A(n.x-t.x)>A(n.y-t.y))?"x":"y",h=i.chartObstacles,c=P(h,t);i=P(h,n);let x;return x=-1<i?(o={start:i=e(o=h[i],n,s),end:n},i):n,-1<c&&(i=e(h=h[c],t,s),a.push({start:t,end:i}),i[s]>=t[s]==i[s]>=x[s]&&(n=t[s="y"===s?"x":"y"]<n[s],a.push({start:i,end:r(i,s,h,s+(n?"Max":"Min"),n?1:-1)}),s="y"===s?"x":"y")),i=r(t=a.length?a[a.length-1].end:t,s,x),a.push({start:t,end:i}),s=r(i,"y"===s?"x":"y",x),a.push({start:i,end:s}),a.push(o),{path:k(a),obstacles:a}}).requiresObstacles=!0;function n(t,n,x){function d(t,n,i){let e,r,a,o,s,h=t.x<n.x?1:-1;for(r=t.x<n.x?(e=t,n):(e=n,t),a=t.y<n.y?(o=t,n):(o=n,t),s=h<0?C(v(g,r.x),g.length-1):0;g[s]&&(0<h&&g[s].xMin<=r.x||h<0&&g[s].xMax>=e.x);){if(g[s].xMin<=r.x&&g[s].xMax>=e.x&&g[s].yMin<=a.y&&g[s].yMax>=o.y)return i?{y:t.y,x:t.x<n.x?g[s].xMin-1:g[s].xMax+1,obstacle:g[s]}:{x:t.x,y:t.y<n.y?g[s].yMin-1:g[s].yMax+1,obstacle:g[s]};s+=h}return n}function l(t,n,i,e,r){var a=r.soft,o=r.hard;let s=e?"x":"y",h={x:n.x,y:n.y},c={x:n.x,y:n.y};r=t[s+"Max"]>=a[s+"Max"];var a=t[s+"Min"]<=a[s+"Min"],x=t[s+"Max"]>=o[s+"Max"],o=t[s+"Min"]<=o[s+"Min"],l=A(t[s+"Min"]-n[s]),M=A(t[s+"Max"]-n[s]);return i=A(l-M)<10?n[s]<i[s]:M<l,c[s]=t[s+"Min"],h[s]=t[s+"Max"],t=d(n,c,e)[s]!==c[s],n=d(n,h,e)[s]!==h[s],i=t?!n||i:!n&&i,i=a?!r||i:!r&&i,o?!x||i:!x&&i}var i=w(x.startDirectionX,A(n.x-t.x)>A(n.y-t.y)),e=i?"x":"y";let r,a=[],M=!1;var o=x.obstacleMetrics;let y=C(t.x,n.x)-o.maxWidth-10,p=j(t.x,n.x)+o.maxWidth+10,f=C(t.y,n.y)-o.maxHeight-10,u=j(t.y,n.y)+o.maxHeight+10,g=x.chartObstacles;var s,h,c,m,b=v(g,y),o=v(g,p);for(-1<(o=P(g=g.slice(b,o+1),n))&&(r=(s=g[o],h=n,c=t,m=C(s.xMax-h.x,h.x-s.xMin)<C(s.yMax-h.y,h.y-s.yMin),c=l(s,h,c,m,{soft:x.hardBounds,hard:x.hardBounds}),m?{y:h.y,x:s[c?"xMax":"xMin"]+(c?1:-1)}:{x:h.x,y:s[c?"yMax":"yMin"]+(c?1:-1)}),a.push({end:n,start:r}),n=r);-1<(o=P(g,n));)b=n[e]-t[e]<0,(r={x:n.x,y:n.y})[e]=g[o][b?e+"Max":e+"Min"]+(b?1:-1),a.push({end:n,start:r}),n=r;return{path:k(t=(t=function t(n,i,e){if(n.x===i.x&&n.y===i.y)return[];var r=e?"x":"y";let a,o,s,h=x.obstacleOptions.margin;var c={soft:{xMin:y,xMax:p,yMin:f,yMax:u},hard:x.hardBounds};return-1<(a=P(g,n))?(c=l(a=g[a],n,i,e,c),O(a,x.hardBounds),s=e?{y:n.y,x:a[c?"xMax":"xMin"]+(c?1:-1)}:{x:n.x,y:a[c?"yMax":"yMin"]+(c?1:-1)},-1<(o=P(g,s))&&(O(o=g[o],x.hardBounds),s[r]=c?j(a[r+"Max"]-h+1,(o[r+"Min"]+a[r+"Max"])/2):C(a[r+"Min"]+h-1,(o[r+"Max"]+a[r+"Min"])/2),M=n.x===s.x&&n.y===s.y&&(M&&(s[r]=c?j(a[r+"Max"],o[r+"Max"])+1:C(a[r+"Min"],o[r+"Min"])-1),!M)),n=[{start:n,end:s}]):(n=[{start:n,end:{x:(r=d(n,{x:(e?i:n).x,y:(e?n:i).y},e)).x,y:r.y}}],r[e?"x":"y"]!==i[e?"x":"y"]&&(c=l(r.obstacle,r,i,!e,c),O(r.obstacle,x.hardBounds),c={x:e?r.x:r.obstacle[c?"xMax":"xMin"]+(c?1:-1),y:e?r.obstacle[c?"yMax":"yMin"]+(c?1:-1):r.y},n=n.concat(t({x:r.x,y:r.y},c,e=!e)))),n.concat(t(n[n.length-1].end,i,!e))}(t,n,i)).concat(a.reverse())),obstacles:t}}return n.requiresObstacles=!0,{fastAvoid:n,straight:function(t,n){return{path:[["M",t.x,t.y],["L",n.x,n.y]],obstacles:[{start:t,end:n}]}},simpleConnect:t}}),n(t,"Gantt/Pathfinder.js",[t["Gantt/Connection.js"],t["Core/Chart/Chart.js"],t["Core/Defaults.js"],t["Core/Globals.js"],t["Core/Series/Point.js"],t["Core/Utilities.js"],t["Gantt/PathfinderAlgorithms.js"]],function(h,t,n,i,r,e,a){function p(t){var n=t.shapeArgs;return n?{xMin:n.x||0,xMax:(n.x||0)+(n.width||0),yMin:n.y||0,yMax:(n.y||0)+(n.height||0)}:(n=t.graphic&&t.graphic.getBBox())?{xMin:t.plotX-n.width/2,xMax:t.plotX+n.width/2,yMin:t.plotY-n.height/2,yMax:t.plotY+n.height/2}:null}function c(t){function s(t,n,i){i=d(i,10);var e=t.yMax+i>n.yMin-i&&t.yMin-i<n.yMax+i,r=t.xMax+i>n.xMin-i&&t.xMin-i<n.xMax+i,a=e?t.xMin>n.xMax?t.xMin-n.xMax:n.xMin-t.xMax:1/0,o=r?t.yMin>n.yMax?t.yMin-n.yMax:n.yMin-t.yMax:1/0;return r&&e?i?s(t,n,Math.floor(i/2)):1/0:u(a,o)}let n=t.length,i=0,e,r,a=[];for(;i<n;++i)for(e=i+1;e<n;++e)(r=s(t[i],t[e]))<80&&a.push(r);return a.push(80),f(Math.floor(a.sort(function(t,n){return t-n})[Math.floor(a.length/10)]/2-1),1)}n=n.defaultOptions;const{addEvent:o,defined:x,error:s,extend:l,merge:M,pick:d,splat:y}=e,f=Math.max,u=Math.min;l(n,{connectors:{type:"straight",lineWidth:1,marker:{enabled:!1,align:"center",verticalAlign:"middle",inside:!1,lineWidth:1},startMarker:{symbol:"diamond"},endMarker:{symbol:"arrow-filled"}}});class g{constructor(t){this.lineObstacles=this.group=this.connections=this.chartObstacleMetrics=this.chartObstacles=this.chart=void 0,this.init(t)}init(t){this.chart=t,this.connections=[],o(t,"redraw",function(){this.pathfinder.update()})}update(t){const e=this.chart,a=this,o=a.connections;a.connections=[],e.series.forEach(function(t){t.visible&&!t.options.isInternal&&t.points.forEach(function(n){var t=n.options;t&&t.dependency&&(t.connect=t.dependency);let i;t=n.options&&n.options.connect&&y(n.options.connect),n.visible&&!1!==n.isInside&&t&&t.forEach(function(t){(i=e.get("string"==typeof t?t:t.to))instanceof r&&i.series.visible&&i.visible&&!1!==i.isInside&&a.connections.push(new h(n,i,"string"==typeof t?{}:t))})})});for(let t=0,n,i,e=o.length,r=a.connections.length;t<e;++t){i=!1;const s=o[t];for(n=0;n<r;++n){const h=a.connections[n];if((s.options&&s.options.type)===(h.options&&h.options.type)&&s.fromPoint===h.fromPoint&&s.toPoint===h.toPoint){h.graphics=s.graphics,i=!0;break}}i||s.destroy()}delete this.chartObstacles,delete this.lineObstacles,a.renderConnections(t)}renderConnections(t){t?this.chart.series.forEach(function(n){function t(){const t=n.chart.pathfinder;(t&&t.connections||[]).forEach(function(t){t.fromPoint&&t.fromPoint.series===n&&t.render()}),n.pathfinderRemoveRenderEvent&&(n.pathfinderRemoveRenderEvent(),delete n.pathfinderRemoveRenderEvent)}!1===n.options.animation?t():n.pathfinderRemoveRenderEvent=o(n,"afterAnimate",t)}):this.connections.forEach(function(t){t.render()})}getChartObstacles(t){let a=[],o=this.chart.series,s=d(t.algorithmMargin,0),n;for(let r=0,t=o.length;r<t;++r)if(o[r].visible&&!o[r].options.isInternal)for(let t=0,n=o[r].points.length,i,e;t<n;++t)(e=o[r].points[t]).visible&&(i=p(e))&&a.push({xMin:i.xMin-s,xMax:i.xMax+s,yMin:i.yMin-s,yMax:i.yMax+s});return a=a.sort(function(t,n){return t.xMin-n.xMin}),x(t.algorithmMargin)||(n=t.algorithmMargin=c(a),a.forEach(function(t){t.xMin-=n,t.xMax+=n,t.yMin-=n,t.yMax+=n})),a}getObstacleMetrics(t){let n=0,i=0,e,r,a=t.length;for(;a--;)e=t[a].xMax-t[a].xMin,r=t[a].yMax-t[a].yMin,n<e&&(n=e),i<r&&(i=r);return{maxHeight:i,maxWidth:n}}getAlgorithmStartDirection(t){var n="top"!==t.verticalAlign&&"bottom"!==t.verticalAlign;return"left"!==t.align&&"right"!==t.align?n&&void 0:n||void 0}}return g.prototype.algorithms=a,i.Pathfinder=g,l(r.prototype,{getPathfinderAnchorPoint:function(t){let n=p(this),i,e;switch(t.align){case"right":i="xMax";break;case"left":i="xMin"}switch(t.verticalAlign){case"top":e="yMin";break;case"bottom":e="yMax"}return{x:i?n[i]:(n.xMin+n.xMax)/2,y:e?n[e]:(n.yMin+n.yMax)/2}},getRadiansToVector:function(t,n){var i;return x(n)||(i=p(this))&&(n={x:(i.xMin+i.xMax)/2,y:(i.yMin+i.yMax)/2}),Math.atan2(n.y-t.y,t.x-n.x)},getMarkerVector:function(t,n,i){var e=2*Math.PI,r=p(this),a=r.xMax-r.xMin;let o=r.yMax-r.yMin,s=Math.atan2(o,a),h=!1;var c=o/2,x=r.xMin+(a/=2),l=x,M=r=r.yMin+c;let d=1,y=1;for(;t<-Math.PI;)t+=e;for(;t>Math.PI;)t-=e;return e=Math.tan(t),-s<t&&t<=s?(y=-1,h=!0):s<t&&t<=Math.PI-s?y=-1:t>Math.PI-s||t<=-(Math.PI-s)?(d=-1,h=!0):d=-1,h?(l+=d*a,M+=y*a*e):(l+=o/(2*e)*d,M+=y*c),i.x!==x&&(l=i.x),i.y!==r&&(M=i.y),{x:l+n*Math.cos(t),y:M-n*Math.sin(t)}}}),t.prototype.callbacks.push(function(t){!1!==t.options.connectors.enabled&&(((t=t).options.pathfinder||t.series.reduce(function(t,n){return n.options&&M(!0,n.options.connectors=n.options.connectors||{},n.options.pathfinder),t||n.options&&n.options.pathfinder},!1))&&(M(!0,t.options.connectors=t.options.connectors||{},t.options.pathfinder),s('WARNING: Pathfinder options have been renamed. Use "chart.connectors" or "series.connectors" instead.')),this.pathfinder=new g(this),this.pathfinder.update(!0))}),g}),n(t,"Extensions/ArrowSymbols.js",[t["Core/Utilities.js"]],function(n){function r(t,n,i,e){return[["M",t,n+e/2],["L",t+i,n],["L",t,n+e/2],["L",t+i,n+e]]}function i(t,n,i,e){return r(t,n,i/2,e)}function a(t,n,i,e){return[["M",t+i,n],["L",t,n+e/2],["L",t+i,n+e],["Z"]]}function e(t,n,i,e){return a(t,n,i/2,e)}const o=[];return{compose:function(t){n.pushUnique(o,t)&&((t=t.prototype.symbols).arrow=r,t["arrow-filled"]=a,t["arrow-filled-half"]=e,t["arrow-half"]=i,t["triangle-left"]=a,t["triangle-left-half"]=e)}}}),n(t,"masters/modules/pathfinder.src.js",[t["Core/Globals.js"],t["Extensions/ArrowSymbols.js"]],function(t,n){n.compose(t.SVGRenderer)})});